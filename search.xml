<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Bugku 2019/10/5 速度要快]]></title>
    <url>%2Funln1999.github.io%2F2019%2F10%2F05%2Fbk17-%E9%80%9F%E5%BA%A6%E8%A6%81%E5%BF%AB%2F</url>
    <content type="text"><![CDATA[进入题目页面提示你要速度要快。 思路查看源码，说让你用post方法传递一个叫margin的量。它的值是多少呢？如果随便给个值，返回结果是”我都说了让你快点。。。”接下来查看html响应头，发现里面有flag。然后只有数字、字母、+、=,是base64加密，加密得到“flag”，然后对这个“flag”再进行一次解密，发现可以解密。把这个值作为margin的值。 writeup写一个快速反弹post的python脚本，内容如下： 1234567891011121314151617181920212223import requests #调用requests库import reimport base64s = requests.session() #创建会话对象r = s.get(&quot;http://123.206.87.240:8002/web6/&quot;)#会话对象的方法,向url发送get请求#第一种#flag = r.headers[&apos;flag&apos;]#flag = base64.b64decode(flag)#flag = flag.decode()#flag = base64.b64decode(flag.split(&quot;:&quot;)[1])#data = &#123;&quot;margin&quot;: flag&#125;#第二种#flag = re.search(r&quot;6LeR55qE6L\+Y5LiN6ZSZ77yM57uZ5L2gZmxhZ\+WQpzogT\w&#123;10&#125;=&quot;,str(r.headers))#flag = base64.b64decode(flag.group(0))#flag = re.search(r&quot;\w&#123;7&#125;[\w =]&quot;,str(flag))#flag = base64.b64decode(flag.group(0))#data = &#123;&quot;margin&quot;: flag&#125;r= s.post(&quot;http://123.206.87.240:8002/web6/&quot;,data)print(r.text) 有两种方式去解密margin的值，第一种是网上常规的，第二种是我用正则表达式写的。在powershell里运行py文件（使用的时候选择一种方法去掉语句的注释）。即可得到flag。 知识点 base64库 base64多次加密 requests库 基于python的快速反弹 正则表达式 split方法 decode html响应头 做了两道快速反弹post的题之后也可以意识到，提交post值还可以用py脚本。]]></content>
      <tags>
        <tag>bugku</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编码和加密]]></title>
    <url>%2Funln1999.github.io%2F2019%2F10%2F04%2F13%E7%BC%96%E7%A0%81%2F</url>
    <content type="text"><![CDATA[编码方式Unicode统一码，为每种语言中的每个字符设定了统一并且唯一的二进制编码。它把所有语言都统一到一套编码里。其通常用两个字节表示一个字符。UTF是Unicode Transfomation Format，是Unicode字符集转换格式。UTF-16都是用两个字节表示，UTF-8可以用一个字节、两个字节和最多三个字节。 UTF-32下面引用一段文字： Unicode 做的跟国人GBK做的类似。但是格局更大。 GBK是收录了绝大部分汉字，部分阿拉伯符号，部分俄文，部分希腊字母等等。Unicode收录的是全世界所有的文字和符号。 Unicode和ASC2兼容，但是与GB2312,GBK都不兼容。所以世界上所有的符号都能用两个字节来表示。这时候，中国人开心了，英文国家的人就不开心了。本来他们用asc2好好的，每个字符用一个字节表示，现在得用两个字节表示，这将占用带宽和硬盘呢。于是他们基于Unicode发明了 UTF-8编码。UTF-8是这样做的： 单字节的字符，字节的第一位设为0，对于英语文本，UTF-8码只占用一个字节，和ASCII码完全相同； n个字节的字符(n&gt;1)，第一个字节的前n位设为1，第n+1位设为0，后面字节的前两位都设为10，这n个字节的其余空位填充该字符unicode码，高位用0补足。这样就形成了如下的UTF-8标记位：0xxxxxxx110xxxxx 10xxxxxx1110xxxx 10xxxxxx 10xxxxxx11110xxx 10xxxxxx 10xxxxxx 10xxxxxx111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx… … 这样，UTF-8存储英文时只用占用一个字节了。省！接下来说说 UTF-16，UTF-16没啥好说的，就是所有字符用两个字节，16位来表示。（但是要分大端对其还是小端对其）UTF-16就是把Unicode码搬过来，简单无脑，只是会多费点空间。 源于这里 urlurl编码是一种浏览器用来打包表单输入的格式，其实url编码就是一个字符ascii码的十六进制。 md5一种被广泛使用的m密码散列函数，可以被破解。因为md5普遍、稳定、快速，所以它仍然用于普通数据的加密保护领域。MD5算法还可以作为一种电子签名的方法来使用，使用 MD5算法就可以为任何文件（不管其大小、格式、数量）产生一个独一无二的“数字指纹”，借助这个“数字指纹”，通过检查文件前后MD5值是否发生了改变，就可以知道源文件是否被改动。MD5加密后通常为16位或32位，16 位实际上是从 32 位字符串中，取中间的第 9 位到第 24 位的部分。 base64Base64是字面意思，它基于64个可打印字符来表示二进制数据。Base64要求把每三个8Bit的字节转换为四个6Bit的字节（38 = 46 = 24），然后把6Bit再添两位高位0，组成四个8Bit的字节，也就是说，转换后的字符串理论上将要比原来的长$\frac{1}{3}$。$2^6=64$,这样刚好可以表示6Bit。属于转义密文，然后会增加长度，便于破解。 加密RSA加密Ron Rivest、Adi Shamir、Leonard Adleman提出。对极大整数做因数分解的难度决定了RSA算法的可靠性。换言之，对一极大整数做因数分解愈困难，RSA算法愈可靠。今天只有短的RSA钥匙才可能被强力方式解破。它通常是先生成一对RSA 密钥，其中之一是保密密钥，由用户保存；另一个为公开密钥，可对外公开，甚至可在网络服务器中注册。为提高保密强度，RSA密钥至少为500位长，一般推荐使用1024位。加密、解密密钥不同。是非对称加密。 des加密des是对称加密，加密解密使用同样的密钥。对称与否说的是信息发送方和接收方对于密码上的地位。类似于转义密文，就是移位和逻辑运算的多次迭代（16次），因此只要知道密钥就很好求解，否则由于多次迭代就难以破解。破解方法是暴力猜解密钥，其安全性会随着计算机的发展而逐渐减弱。但仍有一定强度。密文开头是”U2FsdGVkX1”,可以有密钥也可以无密钥。 古典密码（以下部分大部分为引用，源于这里）重要的会标红【字母表顺序】-数字 加密的时候，经常要把A~Z这26个字母转换成数字，最常见的一种方法就是取字母表中的数字序号。A代表1，B代表2，C代表3… 字母 A B C D E F G H I J K L M N O P Q R S T U V W X Y Z 数字 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 【进制转换密码】 例如二进制：1110 10101 1101 10 101 10010 1111 1110 101 转为十进制：14 21 13 2 5 18 15 14 5 对应字母表：number 【Mod算法】 我们可以对字母序号进行数学运算，然后把所得的结果作为密文。当运算结果大于26或小于1的时候， 我们希望把这个数值转为1~26的范围，那么取这个数除以26的余数即可。 Mod就是求余数的运算符，有时也用“%”表示。例如 29 Mod 26 = 3，或写成 29 % 26 = 3，意思是29除以26的余数是3。 【倒序】 加密时为经常要对字符进行倒序处理。如果让你按abcdef…的顺序背出字母表的每个字母会很容易， 但是如果是zyxwvu…的顺序那就很难背出来了。一个很熟悉的单词，如果按相反的顺序拼写，可能就会感到很陌生。 例如“love”字母倒过来拼就是“evol”。 具体加密时倒序有很多种方案，需要灵活运用。例如： 每个单词的倒序：siht si a tset - this is a test 整句的倒序：tset a si siht - this is a test 数字的倒序：02 50 91 02 - 20 05 19 20(test) 【间隔】 单词之间的间隔一般使用空格。在加密时常常要去掉空格，但有时某些字母或数字来替代空格也不失为一种好的加密方案。 错误空格位置也会起到很强的误导作用。 例如：t hi sis at est - this is a test 【字母频率】 频率分析法可以有效的破解单字母替换密码。 关于词频问题的密码，我在这里提供英文字母的出现频率给大家，其中数字全部是出现的百分比： a 8.2 b 1.5 c 2.8 d 4.3 e 12.7 f 2.2 g 2.0 h 6.1 i 7.0 j 0.2 k 0.8 l 4.0 m 2.4 n 6.7 o 7.5 p 1.9 q 0.1 r 6.0 s 6.3 t 9.1 u 2.8 v 1.0 w 2.4 x 0.2 y 2.0 z 0.1 词频法其实就是计算各个字母在文章中的出现频率，然后大概猜测出明码表，最后验证自己的推算是否正确。 这种方法由于要统计字母出现频率，需要花费时间较长。参考《跳舞的小人》和《金甲虫》。 【凯撒密码(Caesar Shifts, Simple Shift)】 也称凯撒移位，是最简单的加密方法之一，相传是古罗马恺撒大帝用来保护重要军情的加密系统，它是一种替代密码。 加密公式：密文 = (明文 + 位移数) Mod 26 解密公式：明文 = (密文 - 位移数) Mod 26 以《数字城堡》中的一组密码为例： HL FKZC VD LDS 只需把每个字母都按字母表中的顺序依次后移一个字母即可——A变成B，B就成了C，依此类推。因此明文为： IM GLAD WE MET 英文字母的移位以移25位为一个循环，移26位等于没有移位。所以可以用穷举法列出所有可能的组合。 例如：phhw ph diwhu wkh wrjd sduwb 利用电脑可以方便地列出所有组合，然后从中选出有意义的话： qiix qi ejxiv xli xske tevxc rjjy rj fkyjw ymj ytlf ufwyd skkz sk glzkx znk zumg vgxze tlla tl hmaly aol avnh whyaf ummb um inbmz bpm bwoi xizbg vnnc vn jocna cqn cxpj yjach wood wo kpdob dro dyqk zkbdi xppe xp lqepc esp ezrl alcej yqqf yq mrfqd ftq fasm bmdfk zrrg zr nsgre gur gbtn cnegl assh as othsf hvs hcuo dofhm btti bt puitg iwt idvp epgin cuuj cu qvjuh jxu jewq fqhjo dvvk dv rwkvi kyv kfxr grikp ewwl ew sxlwj lzw lgys hsjlq fxxm fx tymxk max mhzt itkmr gyyn gy uznyl nby niau julns hzzo hz vaozm ocz ojbv kvmot iaap ia wbpan pda pkcw lwnpu jbbq jb xcqbo qeb qldx mxoqv kccr kc ydrcp rfc rmey nyprw ldds ld zesdq sgd snfz ozqsx meet me after the toga party &lt;- nffu nf bgufs uif uphb qbsuz oggv og chvgt vjg vqic rctva 可知明文为：meet me after the toga party 【凯撒移位(中文版)】 就是按照中文字在Unicode编码表中的顺序进行移位，可以用来加密中文的信息。 例：[中文凯撒移位] 转换成Unicode编码：中文凯撒移位 移1位后成为： 丮斈凰撓秼低 转换成中文：[丮斈凰挠秼低] 【栅栏密码(The Rail-Fence Cipher)】 也称栅栏易位(Columnar Transposition)，即把将要传递的信息中的字母交替排成上下两行， 再将下面一行字母排在上面一行的后边，从而形成一段密码。栅栏密码是一种置换密码。 例如密文：TEOGSDYUTAENNHLNETAMSHVAED 解密过程：先将密文分为两行 T E O G S D Y U T A E N N H L N E T A M S H V A E D 再按上下上下的顺序组合成一句话 THE LONGEST DAY MUST HAVE AN END. ……………………………………………………. 加密时不一定非用两栏s，还是举《数字城堡》中的一个例子，密文为： PFEE SESN RETM MFHA IRWE OOIG MEEN NRMA ENET SHAS DCNS IIAA IEER BRNK FBLE LODI 去掉空格：PFEESESNRETMMFHAIRWEOOIGMEENNRMAENETSHASDCNSIIAAIEERBRNKFBLELODI 共64个字符，以8个字符为一栏，排列成8*8的方阵(凯撒方阵)： P F E E S E S N R E T M M F H A I R W E O O I G M E E N N R M A E N E T S H A S D C N S I I A A I E E R B R N K F B L E L O D I 从上向下竖着读：PRIMEDIFFERENCEBETWEENELEMENTSRESMONSIBLEFORHIROSHIMAANDNAGASAKI 插入空格：PRIME DIFFERENCE BETWEEN ELEMENTS RESMONSIBLE FOR HIROSHIMA AND NAGASAKI (广岛和长崎的原子弹轰炸的最主要区别) ……………………………………………………. 栅栏密码也可以用于中文，不过比较容易破解。 明文： 这是中文的栅栏密码 密文(3*3方阵)：这文栏是的密中栅码 由于中文用规则的栅栏比较容易破解，所以产生了一些变体，例如道家心法密籍《天仙金丹心法》中的一段加密方法。密文如下： ○ 茫 天 ： 摹 然 月 终 为 鼎 半 是 真 灭 器 轮 假 不 但 伸 净 著 定 分 泥 万 ○ 无 ○ 光 人 经 法 一 从 尘 色 返 我 权 自 法 中 妙 大 空 照 生 屈 来 好 路 形 神 海 ○ 便 还 未 归 ○ 茫 天 ： 摹 然 月 终 为 鼎 半 是 真 灭 器 轮 假 不 但 伸 净 著 定 分 泥 万 ○ 无 ○ 光 人 经 法 一 从 尘 色 返 我 权 自 法 中 妙 大 空 照 生 屈 来 好 路 形 神 海 ○ 便 还 未 归 明文(从上向下竖着读)：天然鼎器净无尘，大海茫茫月半轮。著色空摹终是假，定光返照便为真。不分人我生还灭，但泥经权屈未伸。万法自来归一法，好从中路妙形神。 ……………………………………………………. 利用电脑进行加密或解密，建议使用“列举加密”或“列举解密”，电脑会自动尝试一些正好匹配的栏位进行列举。 lyiroonevuclesey 4栏： loveyousincerely 8栏： lionvceeyroeulsy 【Vigenère Cipher】 由于频率分析法可以有效的破解单表替换密码，法国密码学家维吉尼亚于1586年提出一种多表替换密码， 即维吉尼亚密码，也称维热纳尔密码。维吉尼亚密码引入了“密钥”的概念，即根据密钥来决定用哪一行的密表来进行替换， 以此来对抗字频统计。 加密算法：例如密钥的字母为[d]，明文对应的字母[b]。根据字母表的顺序[d]=4,[b]=2，那么密文就是[d]+[b]-1=4+2-1=5=[e]， 因此加密的结果为[e]。解密即做此逆运算。 加密公式：密文 = (明文 + 密钥) Mod 26 - 1 解密公式：明文 = [26 + (密文 - 密钥)] Mod 26 + 1 也可以用查表法来进行加密：例如密钥的字母为[d]，明文对应的字母[b]，在下图的表格第一行找到字母”d”(深蓝色)， 再在左边第一列找到字母”b”(绿色)，两个字母的交叉点(b行d列)就是字母”E”，所以对应的密文字母为[e]。 [—————–图—————–] a b c d e f g h i j k l m n o p q r s t u v w x y z a A B C D E F G H I J K L M N O P Q R S T U V W X Y Z b B C D E F G H I J K L M N O P Q R S T U V W X Y Z A c C D E F G H I J K L M N O P Q R S T U V W X Y Z A B d D E F G H I J K L M N O P Q R S T U V W X Y Z A B C e E F G H I J K L M N O P Q R S T U V W X Y Z A B C D f F G H I J K L M N O P Q R S T U V W X Y Z A B C D E g G H I J K L M N O P Q R S T U V W X Y Z A B C D E F h H I J K L M N O P Q R S T U V W X Y Z A B C D E F G i I J K L M N O P Q R S T U V W X Y Z A B C D E F G H j J K L M N O P Q R S T U V W X Y Z A B C D E F G H I k K L M N O P Q R S T U V W X Y Z A B C D E F G H I J l L M N O P Q R S T U V W X Y Z A B C D E F G H I J K m M N O P Q R S T U V W X Y Z A B C D E F G H I J K L n N O P Q R S T U V W X Y Z A B C D E F G H I J K L M o O P Q R S T U V W X Y Z A B C D E F G H I J K L M N p P Q R S T U V W X Y Z A B C D E F G H I J K L M N O q Q R S T U V W X Y Z A B C D E F G H I J K L M N O P r R S T U V W X Y Z A B C D E F G H I J K L M N O P Q s S T U V W X Y Z A B C D E F G H I J K L M N O P Q R t T U V W X Y Z A B C D E F G H I J K L M N O P Q R S u U V W X Y Z A B C D E F G H I J K L M N O P Q R S T v V W X Y Z A B C D E F G H I J K L M N O P Q R S T U w W X Y Z A B C D E F G H I J K L M N O P Q R S T U V x X Y Z A B C D E F G H I J K L M N O P Q R S T U V W y Y Z A B C D E F G H I J K L M N O P Q R S T U V W X z Z A B C D E F G H I J K L M N O P Q R S T U V W X Y 假如对如下明文加密： to be or not to be that is the question 当选定“have”作为密钥时，加密过程是：密钥第一个字母为[h]，明文第一个为[t]，因此可以找到在h行t列中的字母[a]，依此类推， 得出对应关系如下： 密钥：ha ve ha veh av eh aveh av eha vehaveha 明文：to be or not to be that is the question 密文：ao wi vr isa tj fl tcea in xoe lylsomvn 【Polybius密码(Polybius Cipher)】 也称棋盘密码，是利用波利比奥斯方阵(Polybius Square)进行加密的密码方式，产生于公元前两世纪的希腊， 相传是世界上最早的一种密码。 假设我们需要发送明文讯息 “Attack at once”， 用一套秘密混杂的字母表填满波利比奥斯方阵，像是这样： A D F G X A b t a l p D d h o z k F q f v s n G g j c u x X m r e w y i和j视为同一个字，使字母数量符合 5 × 5 格。之所以选择这五个字母，是因为它们译成摩斯密码时不容易混淆， 可以降低传输错误的机率。使用这个方格，找出明文字母在这个方格的位置，再以那个字母所在的栏名称和列名称代替这个字母。 可将该讯息转换成处理过的分解形式。 明文：A T T A C K A T O N C E 密文：AF AD AD AF GF DX AF AD DF FX GF XF A,D,F,G,X也可以用数字1,2,3,4,5来代替，这样密文就成了： 13 12 12 13 43 25 13 12 23 35 43 53 【ADFGX/ADFGVX密码(ADFGX/ADFGVX Cipher)】 ADFGX 1918年，第一次世界大战将要结束时，法军截获了一份德军电报，电文中的所有单词都由A、D、F、G、X五个字母拼成， 因此被称为ADFGX密码。ADFGX密码是1918年3月由德军上校Fritz Nebel发明的，是结合了Polybius密码和置换密码的双重加密方案。 A、D、F、G、X即Polybius方阵中的前5个字母。 明文：A T T A C K A T O N C E 经过Polybius变换：AF AD AD AF GF DX AF AD DF FX GF XF 下一步，利用一个移位密钥加密。假设密钥是“CARGO”，将之写在新格子的第一列。再将上一阶段的密码文一列一列写进新方格里。 C A R G O _____ A F A D A D A F G F D X A F A D D F F X G F X F X 最后，密钥按照字母表顺序“ACGOR”排序，再按照此顺序依次抄下每个字母下面的整列讯息，形成新密文。如下： FAXDF ADDDG DGFFF AFAXX AFAFX 在实际应用中，移位密钥通常有两打字符那么长，且分解密钥和移位密钥都是每天更换的。 ADFGVX 在1918年6月，再加入一个字V扩充。变成以6×6格共36个字符加密。这使得所有英文字母（不再将I和J视为同一个字）以及数字0到9都可混合使用。 这次增改是因为以原来的加密法发送含有大量数字的简短信息有问题。 【乘法密码(Multiplication Cipher)】 乘法密码也是一种简单的替代密码，与凯撒密码相似，凯撒密码用的是加法，而乘法密码用的自然是乘法。 这种方法形成的加密信息保密性比较低。 加密公式：密文 = (明文 * 乘数) Mod 26 对于乘数密码，只有当乘数与26互质时，加密之后才会有唯一的解，因此乘数只可能有如下11种的选择： 乘数 = 3,5,7,9,11,15,17,19,21,23,25 仿射密码和希尔密码因为都用到了乘法，所以乘数也受到相同的局限。 【仿射密码(Affine Shift)】 仿射密码就是凯撒密码和乘法密码的结合。 加密公式：密文 = (明文 * 乘数 + 位移数) Mod 26 【希尔密码(Hill Cipher)】 希尔密码就是矩阵乘法密码，运用基本矩阵论原理的替换密码。每个字母当作26进制数字：A=0, B=1, C=2… 一串字母当成n维向量， 跟一个n×n的密钥矩阵相乘，再将得出的结果模26。希尔密码的优点是完全隐藏了字符的频率信息，弱点是容易被已知明文攻击击破。 加密 例如：密钥矩阵 1 3 0 2 明文：HI THERE 去空格，2个字母一组，根据字母表顺序换成矩阵数值如下，末尾的E为填充字元： HI TH ER EE 8 20 5 5 9 8 18 5 HI 经过矩阵运算转换为 IS，具体算法参考下面的说明： |1 3| 8 e18+39=35 MOD26=9 =I |0 2| 9 e08+29=18 MOD26=18=S 用同样的方法把“HI THERE”转换为密文“IS RPGJTJ”，注意明文中的两个E分别变为密文中的G和T。 解密 解密时，必须先算出密钥的逆矩阵，然后再根据加密的过程做逆运算。 逆矩阵算法公式： |A B| = 1/(AD-BC) * | D -B| |C D| |-C A| 例如密钥矩阵= |1 7| |0 3| AD-BC=13-07=3 3*X=1 mod26 所以 X=9 因此 |1 7| 的逆矩阵为： 9 * |3 -7| |0 3| |0 1| 假设密文为“FOAOESWO” FO AO ES WO 6 1 5 23 15 15 19 15 9* |3 -7| | 6| = 9(36-715)=-783 mod26 = 23=W |0 1| |15| = 9(06+115)= 135 mod26 = 5 =E 所以密文“FOAOESWO”的明文为“WEREDONE” 【Playfair密码(Playfair Cipher)】 Playfair将明文中的双字母组合作为一个单元对待，并将这些单元转换为双字母组合。 加密后的字符出现的频率在一定程度上被均匀化。 5*5变换矩阵(I或J视为同一字符)： C I P H E R A B D F G K L M N O Q S T U V W X Y Z 加密规则：按成对字母加密 相同对中的字母加分隔符(如x) ballon -&gt; ba lx lo on 同行取右边：he-&gt;ec 同列取下边：dm-&gt;mt 其他取交叉：kt-&gt;mq od-&gt;tr 例如：ballon -&gt; ba lx lo on -&gt; db sp gs ug 【摩斯电码】 摩斯电码(摩尔斯电码)是一种发报用的信号代码，是一种替代密码，用点(Dot)和划(Dash)的组合来表示各个英文字母或标点。 国际标准摩斯电码表 1 —- A *- N - [.] --- 2 — B -* O — [,] –– 3 *– C --* P – [:] —* 4 **- D -* Q –- [‘] —- 5 ** E * R *- [?] **– 6 -* F **- S * [-] -*- 7 – G –* T - [()] -–- 8 —* H **** U **- [@] *–-* 9 —-* I * V - [—] -- 0 —– J — W – 分数线 -- K -- X -- L *- Y -– 终了[\r] -- M – Z – 始信[\n] --- 例：Hello (斜线代表字母之间的间隔) *//*-/-*/—/ 【置换密码(Transposition Cipher)】 也称易位密码。 【替代密码(Monoalphabetic Substitution)】 也称单表替换密码。 【字母表数字 】 用1-26这些数字分别表示A-Z的字母。 字母 A B C D E F G H I J K L M N O P Q R S T U V W X Y Z 数字 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 【字母表代码】 同字母表数字，只是把10以下的数字添0补位。 字母 A B C D E F G H I J K L M N O P Q R S T U V W X Y Z 数字 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 【反字母表】 就是丹·布朗在《达·芬奇密码》一书中提到的埃特巴什码(Atbash Cipher)。它的原理是取一个字母， 指出它位于字母表正数第几位，再把它替换为从字母表倒数同样的位数后得到的字母。如：E被替换为V，N被替换为M等。 明码表 A B C D E F G H I J K L M N O P Q R S T U V W X Y Z 密码表 Z Y X W V U T S R Q P O N M L K J I H G F E D C B A 明文：sophia 密文：hlksrz 【随机乱序字母】 即单字母替换密码。重排密码表二十六个字母的顺序，密码表会增加到四千亿亿亿多种， 能有效的防止用筛选的方法检验所有的密码表。这种密码持续使用几个世纪，直到阿拉伯人发明了频率分析法。 明码表 A B C D E F G H I J K L M N O P Q R S T U V W X Y Z 密码表 Q W E R T Y U I O P A S D F G H J K L Z X C V B N M 明文：forest 密文：gbmrst 【棋盘密码】 即Polybius密码。 【键盘密码】 加密的原理同棋盘密码，只是利用了键盘作为方阵。 键盘的字母分布： ~!@#$%^&amp;*()_+| `1234567890-=\ QWERTYUIOP{} qwertyuiop[] ASDFGHJKL:” asdfghjkl;’ ZXCVBNM&lt;&gt;? zxcvbnm,./ 密文：72 81 12 63 01 12 63 明文：jianpan 低下头看看键盘就知道了，密文就是键盘上的26个字母的坐标，72即第7列第2行，第7列正好是数字键[7]的位置，往下2个就是字母[J]。【键盘移位】 密文：kosm[sm 明文：jianpan 就是键盘上的字母往右一个。例如[j]键的右面是[k]，[i]键的右面是[o]，依此类推。【软键盘密码】 密文1：まはす にはつ へつ たっゃの せちなゃ ひつなゃ てなゃ ひつな ゅつ ぬす 密文2：ㄈㄘㄍ ㄋㄘㄛ ㄠㄛ ㄗㄟㄙㄕ ㄐㄧㄇㄙ ㄨㄛㄇㄙ ㄣㄇㄙ ㄨㄛㄇ ㄩㄛ ㄎㄍ 密文3：црв мрж уж езып гёлы сжлы илы сжл ьж нв 密文4：＃←☆ △←◇ 〓◇ ●◆＿→ ★◎■＿ ↑◇■＿ □■＿ ↑◇■ ￣◇ ▲☆ 明文：zhe shi li yong ruan jian pan jia mi de(这是利用软键盘加密的) 用智能ABC或微软拼音输入法，把小键盘打开，选择日本平假名字符，输入“zhe shi”就会出现“まはす にはつ”， 如果切换到俄文字符就会出现“црв мрж”……【数字小键盘密码】 数字小键盘的字母分布： 7 8 9 4 5 6 1 2 3 密文：852 74123 741236987 74269 78974123456 7412369 明文：I L O V E U 对照小键盘，依次打这些字母，看组成的形状就行了。 关于Alt+小键盘数字的加密方法，参看：百度/Google/网页字符。 【手机键盘密码】 根据手机键盘上的数字和对应的字母进行加密。 密文：42 21 71 71 93 明文：HAPPY “42”：4键对应的是GHI，GHI第2个就是H；“21”：2键对应的是ABC，ABC第1个就是A。 加密时往往只出现数字键，而不给出具体的字母位置，这时解密时就要列举所有可能的组合，从中选出有意义的单词来。 例如密文：42779，这时就要从 GHI ABC PQRS PQRS WXYZ 中提出有意义的字符：HAPPY 另一种方法是根据形状加密的，和数字小键盘密码相同，按照密码里的数字比划一下就划出来了。 比如密文173946，对应的明文是H，17是左边一竖，39是右边一竖，46是中间一横。 【百度/Google/网页字符】 下面解释一下在百度、Google搜索中文的关键词时，地址栏上出现的奇怪字符。 百度字符(GB2312) 例如在百度搜索“你好”两个字，会转到一个地址为 http://www.baidu.com 的网页。 密文(GB码16进制)：%C4%E3%BA%C3 密文(GB码十进制)：50403 47811 明文：你好 百度用的是GB2312的中文编码，是16进制的。GB2312是标准的简体中文编码。“你”字的GB码为C4E3，“好”字的GB码为BAC3。 “你好”转换成十进制为50403和47811。 Google字符(URI) 例如在Google搜索“你好”两个字，会转到一个地址为 http://www.google.cn 的网页。 密文(URI)：%E4%BD%A0%E5%A5%BD 明文：你好 URI全称Uniform Resource Identifier(通用资源标识符)。Internet可用的每种资源 - HTML文档、图像、视频片段、程序等 - 由一个通过URI进行定位。 网页编码(Unicode) 论坛里常玩的一个把戏，就是让你回帖时写一堆像天书一样的奇怪字符，而回帖之后就能看到相应的文字。 密文(Unicode16进制)：楼主是个天才 密文(Unicode10进制)：楼主是个天才 明文：楼主是个天才 这里使用的是Unicode编码(十进制)，Unicode是一种全世界范围的文字编码，网页都支持这种编码。 Alt+数字小键盘 按住Alt键，在任意文本框中，用键盘右边的数字小键盘输入55021，然后松开Alt键，这时你看到了什么？ 用同样的方法分别输入“你好”两个字的GB代码(十进制)50403、47811，这时你将在文本框中看到这两个字。 注意在qq的对话框中，要使用Unicode代码(十进制)20320、22909。【元音密码】元音密码的原则很简单，即将五个元音字母分别标号1，2，3，4，5，然后将26个英文字母的对应表码写成如下的形式：a b c d e f g h i j k l m n o p q r s t u v w x y z1 11 12 13 2 21 22 23 3 31 32 33 34 35 4 41 42 43 44 45 5 51 52 53 54 55然后进行加密即可。 题目：45.23.2.33.1.44.45.44.3.22.23.45对应上表解出明文：the last sight（最后一面）.需要说明的是，元音字母因为密文中只含有1，2，3，4，5五个数字而且时常出现个位数，因此很容易破解，有时候可以将1，2，3，4，5变为10，20，30，40，50等，也可变成如同棋盘密码密文的形式来对解密者进行干扰。【云影密码】此密码运用了1248代码，因为本人才疏学浅，尚未发现有过使用的先例，因此暂归为原创密码，若有密码界前辈认为不妥，请指出此密码或类似密码的普遍使用历史并附寄一份到我站内邮箱，我将以最快速度核查并改正。由于这个密码，我和片风云影初识，为了纪念，将其命名为“云影密码”，原文请见谜题大全精华区。原理很简单，有了1，2，4，8这四个简单的数字，你可以以加法表示出0-9任何一个数字，例如0=28，7=124，9=18。这样，再用1-26来表示A-Z，就可以用作密码了。为了不至于混乱，我个人引入了第五个数字0，来用作间隔，以避免翻译错误，所以还可以称“01248密码”。 题目：12401011801180212011401804第一步，分割，即124 1 118 118 212 114 18 4第二步，基本翻译，例如124可以表示7，也可以表示16（但不可能是34，因为不会超过26），所以可以放在一边，翻译其他没有异议的，可得：124 a s s w o 18 d第三步，推测得出明文。可以推测后面的18表示r，前面的为p最合适。 明文：password（密码）.(五)四位乘法密码——（密文：I Q V L N J O P X；密钥：1234）自古密文的传递者最担心的就是密文和密钥同时落入敌手，这样，密码的效应也就所剩无几了，所以通常会将两样东西以不同的方式在不同的时间进行传送。但是，后来有一个叫前天淫次郎的日本鬼子发明了一种加密方式，这种加密方式使得即使密钥落入敌手也不会轻易暴露，一时很令敌手头疼。这种加密方式的关键是密钥，简短但是实用。下面介绍其使用及破译方法：首先，任意选取一个个十百位数均无零的四位数，如题目中的密钥，即1234；其次，将上述四位数做平方处理，即1234×1234=1522756,取中间三位数，即227；再次，用所得数字与1234相乘，即227×1234=280118，取“中间三位”（之前传递和接收密文的双方要有所约定比如遇到像280118这样的数字，是取‘801’还是取‘011’），这里取801；依次类推，直到所得的三位数所含数字总个数大于或等于密文的字母个数为止，即801×1234=988434，取884。这样，最终得到的一组码是227801884。最后，将这组码标在密文下，向前推相应的位数即可得到明文，即 密文：I Q V L N J O P X密钥：2 2 7 8 0 1 8 8 4明文：g o o d n i g h t(Good night!)【费娜姆密码】（密码：00110110010001001100100010000010110；密钥：study） 二战时德军使用过的一种密码，其实是利用了二进制的表示法来替代字母，有如下的表格作为基础： A 1000001 B 1000010 C 1000011 D 1000100 E 1000101 F 1000110 G 1000111 H 1001000 I 1001001 J 1001010 K 1001011 L 1001100 M 1001101 N 1001110 O 1001111 P 1010000 Q 1010001 R 1010010 S 1010011 T 1010100 U 1010101 V 1010110 W 1010111 X 1011000 Y 1011001 Z 1011010 那么，比如我们要加密“Hello”，密钥用“study”，则以如下方式进行加密： H E L L O = 1001000 1000101 1001100 1001100 1001111S T U D Y = 1010011 1010100 1010101 1000100 1011001 加密原则：1+1=0，0+0=0，1+0=1 于是得密文：00110110010001001100100010000010110 那么解题目中的密文，需要遵循以下几个原则和步骤， 1，划分，即每七个数字为一组； 2，对应，找出密文每个字母对应的数字，再与上述数字对应； 3，转换，遵循上述加密原则，逆用即可； 4，解密，得出新的一组数字，对应字母，得出明文。]]></content>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bugku 2019/10/4 秋名山老司机]]></title>
    <url>%2Funln1999.github.io%2F2019%2F10%2F04%2Fbk16-%E7%A7%8B%E5%90%8D%E5%B1%B1%E8%80%81%E5%8F%B8%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[进入题目页面让你计算一个值，在2秒内，那么他怎么知道你在两秒内算好呢？本题是快速反弹post请求。刷新页面，算式会变，文字提示有时候会变成英文，里面有post字眼。先要在python安装requests库。 1&gt;pip install request 如果失败离线安装，离线包下载点这里,进去后搜索requests。下载形如requests-2.22.0-py2.py3-none-any的文件。然后中途可能还是会缺很多库……要再去下载。 思路利用python的request库做快速反弹 writeup安装好需要的库后，可以用如下代码： 12345678910import requests #调用requests库import res = requests.Session() #创建会话对象r = s.get(&quot;http://123.206.87.240:8002/qiumingshan/&quot;) #会话对象的方法,向url发送get请求searchobj = re.search(r&quot;(\d+[+\-*])+(\d+)&quot;,r.text)#原生正则表达式,text是对象r的属性d = &#123; &quot;value&quot;: eval(searchobj.group(0)) &#125;r= s.post(&quot;http://123.206.87.240:8002/qiumingshan/&quot;,data = d)print(r.text) 以下是正则表达式含义在powershell里运行py脚本，就可以得到flag。并不是每次都能成功，所以要重复几次。 知识点 基于python的快速反弹 requests库 re库 正则表达式]]></content>
      <tags>
        <tag>bugku</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bugku 2019/10/3 点击一百万次]]></title>
    <url>%2Funln1999.github.io%2F2019%2F10%2F03%2Fbk15-%E7%82%B9%E5%87%BB%E4%B8%80%E7%99%BE%E4%B8%87%E6%AC%A1%2F</url>
    <content type="text"><![CDATA[jQuery是一个快速、简洁的JavaScript框架，是继Prototype之后又一个优秀的JavaScript代码库（或JavaScript框架）。jQuery设计的宗旨是“write Less，Do More”，即倡导写更少的代码，做更多的事情。jQuery中#可作为id选择器。!(bk15-1)(/img/bk15-1.png)W3C参考 进入题目页面显示着点击曲奇饼增加点击数的界面。html里的js源码是： 1234567891011121314151617181920212223242526272829303132&lt;script&gt; var clicks=0 $( function() &#123; $(&quot;#cookie&quot;) .mousedown ( function() &#123; $(this).width(&apos;350px&apos;).height(&apos;350px&apos;);//控制形状变小 &#125; ) .mouseup ( function() &#123; $(this).width(&apos;375px&apos;).height(&apos;375px&apos;);//恢复原来的形状 clicks++;//增加点击数 $(&quot;#clickcount&quot;).text(clicks);//id为clickcont的html标签的文本改为点击数 if(clicks &gt;= 1000000)//如果这个点击数大于等于1000000了 &#123; var form = $(&apos;&lt;form action=&quot;&quot; method=&quot;post&quot;&gt;&apos; +&apos;&lt;input type=&quot;text&quot; name=&quot;clicks&quot; value=&quot;&apos; + clicks + &apos;&quot; hidden/&gt;&apos; + &apos;&lt;/form&gt;&apos;);//声明一个叫form的变量，是一串字符串。 //就是一个表单，以post方式，传递名为clicks的表单值，然后输入框被隐藏，值是一个字符串。 $(&apos;body&apos;).append(form);//在html的body标签里追加子元素form。 form.submit();//提交表单值 &#125; &#125; ); &#125; ); &lt;/script&gt; 关于form.submit，就是把js里的表单给提交了。 思路我们不用js代码，直接传递clicks值。 writeup用hackbar提交post值，注意不要加空格。然后就出现flag了。 也可以直接在bp里改变request method。 知识点 jquery阅读 post值提交]]></content>
      <tags>
        <tag>bugku</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bugku 2019/10/2 输入密码查看flag]]></title>
    <url>%2Funln1999.github.io%2F2019%2F10%2F02%2Fbk14-%E8%BE%93%E5%85%A5%E5%AF%86%E7%A0%81%E6%9F%A5%E7%9C%8Bflag%2F</url>
    <content type="text"><![CDATA[进入题目页面意思是让你输入查看密码，而且提示了密码是5位数。 思路甚至url里有着baopo的字眼，因此这道题可以使用bp的intruder暴力破解。 writeup利用字典生成器或者intruder的numbers payloads来爆破。因为密码开头是1。不用跑全程就可以得到正确密码。另外，注意positions设置只设置要爆破的字段。最后得到密码位13579 知识点 bp暴力破解 字典生成]]></content>
      <tags>
        <tag>bugku</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bugku 2019/10/1 web4]]></title>
    <url>%2Funln1999.github.io%2F2019%2F10%2F01%2Fbk13-web4%2F</url>
    <content type="text"><![CDATA[进入题目页面有一段文字“看看源代码？”一个输入框，一个写着提交的按钮。 思路不用说也要看源代码。看到form向index.php用post传递参数。输入框的名字叫flag，应该是检验flag对错的。输入1，看看反应。说“再好好看看”。根据之前的经验，就是检验flag对错。html代码里有一段script。是escape加密。 writeupeval里的代码看起来没有执行。我们直接输出，看看效果是什么。 12345678910&lt;html&gt;&lt;title&gt;BKCTF-WEB4&lt;/title&gt;&lt;body&gt;&lt;script&gt;var p1 = &apos;%66%75%6e%63%74%69%6f%6e%20%63%68%65%63%6b%53%75%62%6d%69%74%28%29%7b%76%61%72%20%61%3d%64%6f%63%75%6d%65%6e%74%2e%67%65%74%45%6c%65%6d%65%6e%74%42%79%49%64%28%22%70%61%73%73%77%6f%72%64%22%29%3b%69%66%28%22%75%6e%64%65%66%69%6e%65%64%22%21%3d%74%79%70%65%6f%66%20%61%29%7b%69%66%28%22%36%37%64%37%30%39%62%32%62&apos;;var p2 = &apos;%61%61%36%34%38%63%66%36%65%38%37%61%37%31%31%34%66%31%22%3d%3d%61%2e%76%61%6c%75%65%29%72%65%74%75%72%6e%21%30%3b%61%6c%65%72%74%28%22%45%72%72%6f%72%22%29%3b%61%2e%66%6f%63%75%73%28%29%3b%72%65%74%75%72%6e%21%31%7d%7d%64%6f%63%75%6d%65%6e%74%2e%67%65%74%45%6c%65%6d%65%6e%74%42%79%49%64%28%22%6c%65%76%65%6c%51%75%65%73%74%22%29%2e%6f%6e%73%75%62%6d%69%74%3d%63%68%65%63%6b%53%75%62%6d%69%74%3b&apos;;eval(document.write(unescape(p1) + unescape(&apos;%35%34%61%61%32&apos; + p2)));&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 结果得到： 1function checkSubmit()&#123;var a=document.getElementById(&quot;password&quot;);if(&quot;undefined&quot;!=typeof a)&#123;if(&quot;67d709b2b54aa2aa648cf6e87a7114f1&quot;==a.value)return!0;alert(&quot;Error&quot;);a.focus();return!1&#125;&#125;document.getElementById(&quot;levelQuest&quot;).onsubmit=checkSubmit; 这是定义了一个checkSubmit的函数。当a被赋值时，如果a的值是67d709b2b54aa2aa648cf6e87a7114f1时可能会发生一些事情，checkSubmit返回。猜测a就是输入框里的东西。输入以上字符串，返回结果即为flag。很遗憾这个不是检验flag对错，而是用密文获取正确flag，思路里的猜想并不对。 知识点 eval() unescape JSP基础知识]]></content>
      <tags>
        <tag>bugku</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bugku 2019/9/30 管理员系统]]></title>
    <url>%2Funln1999.github.io%2F2019%2F09%2F30%2Fbk12-%E7%AE%A1%E7%90%86%E5%91%98%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[进入题目页面可以看到一个管理员系统的登录页面，有Username、Password还有提交、重置按钮。 思路一般来说管理员账号是admin、root、administrator等。这里的密码看起来需要暴力破解，但其实不然，在源代码里可以发现一行被注释的玩意儿。试着解密。【是base64加密】然后登录。登录后发现提示“IP禁止访问，请联系本地管理员登陆，IP已被记录. ”意思就是本机IP不允许登录。因此想到修改HTTP请求包，加入X-Forwarded-For头字段（大小写没有严格要求，但一般来说头字段里每个单词首字母大写）。 writeuphtml代码里获得： 1&lt;!-- dGVzdDEyMw== --&gt; 利用base64解码得：“test123”。猜测这是密码。然后尝试用户名为admin。第一次尝试登录失败。没有那么简单。伪造真实IP为本地IP127.0.0.1。登录成功。回头我又试了一下root作为用户名。返回结果为：使用administrator和输错密码也是同样的结果。 虽然做出来了，我们用BP找一下用户名。用“去生日最小字典”（我个人感觉蛮实用的字典）暴力破解用户名。实际上在intruder里就可以得到flag。 知识点 base64加密 伪造真实IP bp暴力破解]]></content>
      <tags>
        <tag>bugku</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2Funln1999.github.io%2F2019%2F09%2F29%2F12%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[参考网址挑了部分来讲，全部写清还是有点困难。以实用为主。 什么是正则表达式正则表达式是一种特殊的字符串模式，用于匹配一组字符串，定义一种规则去匹配符合规则的字符。 常用的正则表达式工具可以使用McTracer 正则字符简介元字符介绍^ 匹配行或字符串的起始位置$ 匹配行或字符串的结尾\b 不消耗字符、匹配一个位置（blank）\d 匹配数字（digit）\w 匹配字母、数字、下划线（word）\s 匹配空格. 匹配除了换行符的任意字符[abc] 字符组，匹配括号内的所有字符字母类的大写取反义，字符组加^取反义。 量词贪婪*：重复0次或更多占有+：重复1次或更多懒惰？：重复零次或一次{n}：重复n次{n，m}：重复n到m次{n，}：重复n次或更多 懒惰限定符尽可能少重复。 进阶捕获分组利用数字来对（）括号内的捕获内容进行分组。加入?可以对分组命名。(?=exp)匹配exp前面的内容(?&lt;=exp)匹配exp后面的内容 感觉还有不少内容没有涵盖进去，先这样吧 2019/9/29 20:33]]></content>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript基础]]></title>
    <url>%2Funln1999.github.io%2F2019%2F09%2F29%2FJS%2F</url>
    <content type="text"><![CDATA[JSP简介JavaScript 是可插入HTML页面的编程代码。它可以做到以下的事： 直接写入html输出流（document.write） 对事件的反应（通过button） 改变html内容（利用getElementById找到唯一id对应的html元素，再用.innerHTML改变内容） 改变html图像（通过element.src来改变图像的source） 改变html样式 验证输入 JSP用法必须位于script标签之间。既可放在body也可放在head里。还可以将JavaScript保存在外部文件里。 JSP输出 window.alert() document.write() 使用innerHTML写入html元素中。 console.log写入浏览器的控制台中。 JSP语法//是注释，也可以用/**/语句用;作结JSP对大小写敏感。其它和别的编程语言差不多。 JSP语句和C差不多 JSP变量加var来声明。是弱类型的。可以声明多个变量。还可以跨行。重新声明，值不会改变。 JSP数据类型字符串、数字、布尔值、null、undefined、Symbol。数据具有动态类型，可以通过赋值而改变数据类型。JSP数组和C有一定区别。JSP对象由花括号分隔。在括号内部，对象的属性以名称和值对的形式 (name : value) 来定义。属性由逗号分隔。可以用关键字new来声明变量类型。 JSP对象对象是拥有属性和方法的数据。在 JavaScript 中，对象是非常重要的，当你理解了对象，就可以了解 JavaScript 。对象的方法定义了一个函数。 JSP函数函数内的都是局部变量，函数内的都是局部变量，函数外的是全局变量。 JSP作用域作用域是可访问变量的集合。 JSP事件1&lt;some-HTML-element some-event=&quot;JavaScript 代码&quot;&gt;]]></content>
      <tags>
        <tag>web</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bugku 2019/9/29 网站被黑]]></title>
    <url>%2Funln1999.github.io%2F2019%2F09%2F29%2Fbk11-%E7%BD%91%E7%AB%99%E8%A2%AB%E9%BB%91%2F</url>
    <content type="text"><![CDATA[进入题目页面这道题的题目是网站被黑，但是这个题目“网站”并没有被黑，而你需要做的事就是侵入webshell。 思路webshell是以php、asp等网页文件形式存在的命令执行环境，一开始不知道网页后台的网页文件有哪些。因此使用web后台扫描工具扫出所有网页文件。然后寻找webshell，找到后，破解密码即可攻入。 writeup利用某御剑扫描工具，将域名“http://123.206.87.240:8002/webshell/”输入到软件中，点击开始扫描，等待片刻获得扫描结果。然后发现“http://123.206.87.240:8002/webshell/shell.php”就是webshell。然后利用bp破解密码。方法是，首先在页面提交一次密码，然后在proxy里的history里找到发送过去的post包，将这个包发送给intruder，然后设置“破解字段”。再在payloads里添加字典，然后start attack即可获取密码。在弱字典里的最后部分里匹配到了密码，hack。（字典附在后面） 知识点 黑入网站 网站后台扫描 bp暴力破解 字典computercpumemorydisksofty2ksoftwarecdromromadminmastercardpcilockasciiknightcreativemodeminternetintranetwebwwwispunlockftptelnetibmintelmicrosoftdellcompaqtoshibaacerinfoaol56kserverdoswindowswin95win98officewordexcelaccessunixlinuxpasswordfileprogrammp3mpegjpeggifbmpbillgateschipsiliconsonylinkword97office97networkramsunyahooexcitehotmailyeahsinapcweekmacapplerobotkeymonitorwin2000office2000word2000netviruscompanytechtechnologyprintcoolwebguestprintersupermanhotpageentermywebdownloadcoolcoolmancoolboycoolgirlnetboynetgirllogloginconnectemailhyperlinkurlhotwebjavacgihtmlhtmhomehomepageicqmykeyc++basicdelphipascalanonymouscrackhackhackerchinesevcdchatchatroommudcrackerhappyhelloroomenglishusernetizenfrontpageagpnetwolfusahotsiteaddressmailnewstopcool000000000100200700810th1st2nd3rd4th5th6th7th8th9th10010110813316316618823326635036645046613613713813915816816919219820022223323425828830030133334538840043345645850055555858860066659866867868888898899910881100118812341288138815881688188819491959196019611962196319641965196619671968196919701971197219731974197519761977197819791980198119821983198419851986198719881989199019971999200020012002208821002188234525883000372138884567472855555678588866666688678968887788888888999988999912345234563456745678543218888812345665432188888866665678912345671234567812345678912345678900123456780123456789012345678907377771111222233334321]]></content>
      <tags>
        <tag>bugku</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bugku 2019/9/28 web5]]></title>
    <url>%2Funln1999.github.io%2F2019%2F09%2F28%2Fbk10-web5%EF%BC%88jjencode%EF%BC%89%2F</url>
    <content type="text"><![CDATA[打开题目界面显示一段文字和一个文本框和提交按钮。 思路打开html代码，分区里有一堆字符，第一次看真的不知道是干啥的。然后就是很正常的两个表单。题目的意思是让你输入正确的flag，然后提交后会反馈给你是否正确。我们先随便输点东西，看一下有没有错误反馈。结果是有的，作者让你再看一下。于是就研究html代码。但是不知道那堆字符是干嘛的，于是去查了writeup。提示中的JSPFUCK中的JSP是指java server page。这个好像也是一种加密，不太清楚到底是jjencode还是jspfuck。总之，把这段字符放在控制行里，回车得到java代码。 writeup复制字符到浏览器console并回车。得到flag，然后输入后发现不对。再由题干中的字符大写启发，改为大写，则正确。 知识点 jsp加密]]></content>
      <tags>
        <tag>bugku</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bugku 2019/9/27 头等舱]]></title>
    <url>%2Funln1999.github.io%2F2019%2F09%2F27%2Fbk9-%E5%A4%B4%E7%AD%89%E8%88%B1%2F</url>
    <content type="text"><![CDATA[进入题目页面显示“什么都没有” 思路因为直接显示的内容里没有明显的线索。因此看源代码。发现也没有内容。这时候再看更根本的HTTP响应。 writeup打开bp，把get请求发送到repeater里，然后go一下，接收返回来的http响应。然后可以发现，响应头标里有flag。 知识点 HTTP响应头标]]></content>
      <tags>
        <tag>bugku</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bugku 2019/9/26 你必须让他停下]]></title>
    <url>%2Funln1999.github.io%2F2019%2F09%2F26%2Fbk8-%E4%BD%A0%E5%BF%85%E9%A1%BB%E8%AE%A9%E5%AE%83%E5%81%9C%E4%B8%8B%E6%9D%A5%2F</url>
    <content type="text"><![CDATA[进入题目页面进入后，可以看到页面一直在刷新。有个图片一直在变，还有一些话，意识是，当你看到熊猫的时候，就会看到flag。 思路做web题要看F12，页面一直在刷新，所以不便于看html代码。因此用bp抓包，让页面刷新可控。应该每个图本来都是会显示的，应该是服务器里出了什么问题，导致图片显示不出来。所以正常情况下，我们看刷新的页面，是会出现熊猫的。并且我们不能发现flag。我们观察html代码。可以发现有一句： 1&lt;a style=&quot;display:none&quot;&gt;flag is here~&lt;/a&gt; 看到display可以猜测flag会在这个书签语句里出现，并且它会被隐藏。 writeup要刷新页面到出现熊猫时才会有flag。因此把第一个包（连接服务器的get包，我还不太懂qaq）发送到repeater里。重复获取页面。最终flag会出现。如果过头了的话，repeater里可以倒退。 知识点 repeater刷新初始页面]]></content>
      <tags>
        <tag>bugku</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bugku 2019/9/25 host]]></title>
    <url>%2Funln1999.github.io%2F2019%2F09%2F25%2Fbk7-host%2F</url>
    <content type="text"><![CDATA[进入题目页面其实没有题目页面，就是有个题目。然后内容是：“听说把 flag.baidu.com 解析到123.206.87.240 就能拿到flag” 思路第一次做且不懂hosts肯定无法理解什么意思。所以我查了writeup，才知道是要添加到hosts文件里。至于题目背后的原理，我还是不太清楚。 writeup找到系统的hosts文件。然后另起一行输入： 1123.206.87.240 flag.baidu.com 知识点 hosts设置]]></content>
      <tags>
        <tag>bugku</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bugku 2019-9-24 web3]]></title>
    <url>%2Funln1999.github.io%2F2019%2F09%2F24%2Fbk6-web3%2F</url>
    <content type="text"><![CDATA[进入题目页面出现了一些列弹窗。说flag就在这里。 思路点击几次弹窗，发现还在弹。考虑无限弹窗的可能性，直接不管弹窗，打开开发者工具（F12）。阅读代码，发现一段被注释的HTML特殊字母编码，猜测这是flag。 writeup把这个特殊编码写入一个html文档里，直接打开，会译为字符串。结果就是flag。 知识点 html注释 html特殊字母编码]]></content>
      <tags>
        <tag>bugku</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[双极型晶体管及其基本放大电路——模电Charpter3]]></title>
    <url>%2Funln1999.github.io%2F2019%2F09%2F24%2Fmd3%2F</url>
    <content type="text"><![CDATA[1. 双极型晶体管1.1 晶体管的结构、类型和三种组态结构就是由发射极、基极、集电极组成。 类型有NPN型和PNP型。 组态有共基极接法、共发射极接法、共集电极接法。 1.2 晶体管的电流放大作用共基极直流放大系数 α共射极直流放大系数 β1.3 晶体管的共射特性曲线和主要参数输入特性曲线$U_{CE}$不变，$i_B$和$U_{BE}$的关系和二极管正向特性曲线相似。 输出特性曲线$i_B$不变，$i_C$随$U_{CE}$的增大而增大直至饱和。（$U_{CE}$） 主要参数参数有直流参数、交流参数、极限参数三类。 直流参数（加横杠表示直流）β：当$U_{CE}$不变时，输出集电极电流和输入基极电流的比值。α：见上。 交流参数交流放大系数和直流的差不多。特征频率截止频率有：$f_α=f_T=β·f_β$ 极限参数集电极最大允许电流集电极最大允许功耗 2. 放大的概念和放大的性能指标]]></content>
      <tags>
        <tag>模电</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bugku 2019-9-23 矛盾]]></title>
    <url>%2Funln1999.github.io%2F2019%2F09%2F23%2Fbk5-%E7%9F%9B%E7%9B%BE%2F</url>
    <content type="text"><![CDATA[进入题目页面给出了文本。 1234567$num=$_GET[&apos;num&apos;];if(!is_numeric($num))&#123;echo $num;if($num==1)echo &apos;flag&#123;**********&#125;&apos;;&#125; 思路显然是php代码。和SQL注入类似，我们提交的表单值也可以进行注入。首先明确我们输出flag的前提。 ＄num不是数 ＄num后加==1是一个真值＄num不是一个数，那它可以是字符串。逻辑表达式为真可以嵌套or和and。所以我们用一个含“==1”的字符串来作为真值。 writup取＄num为’1 or 1’，这个是随便想的一个。1 or 1==1布尔值为真。然后在url里提交，就可以得到flag。 知识点 代码注入思想 如何提交get变量]]></content>
      <tags>
        <tag>bugku</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bugku 2019-9-22 计算器]]></title>
    <url>%2Funln1999.github.io%2F2019%2F09%2F22%2Fbk4-%E8%AE%A1%E7%AE%97%E5%99%A8%2F</url>
    <content type="text"><![CDATA[进入题目页面显示了一个验证码（应该靠后端脚本生成，不在html里体现。）然后还有一个文本框。 思路猜测输入正确的验证码之后，会出现flag。然而文本框只能输入一位数字。猜测是受到了限制。因此查看html代码。发现这里限制了maxlength。然后这个文本框不是表单，因此无法通过修改get、post表单值。强行改变html代码，来使页面发生变化。 writeup把maxlength去掉或加长。然后输入正确的验证码。flag出来了。 知识点 html代码是可以直接修改的，甚至强行添加新的内容。]]></content>
      <tags>
        <tag>bugku</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[热学公式和一些细节]]></title>
    <url>%2Funln1999.github.io%2F2019%2F09%2F22%2Fdw-%E7%83%AD%E5%AD%A6%E5%85%AC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[只需要记红色的公式！第17章 气体动理论 理想气体状态方程N、V、P、T$PV=νRT$$PV=NkT$$P=nkT$ 理想气体压强（这个公式不记）N、V、P、$\varepsilon_t$$P=\frac{2}{3}n\varepsilon_t$(n为单位体积分子数)$PV=\frac{2}{3}N\varepsilon_t$ 理想气体分子平均平动动能\varepsilon_t、T$\varepsilon_t=\frac{3}{2}kT$ 分子总平均动能$\varepsilon_k=\frac{i}{2}kT$ 气体内能$E=N\varepsilon_k$ 三种速率$v_{rms}$是用来算平均平动动能的。$\varepsilon_t=\frac{1}{2}mv_{rms}^2另外两个目前没用（我感觉） 小结：本章研究气体的几个表征量。微观的有：分子平均平动动能、分子平均动能【公式3】宏观的有：气压、气温、分子浓度、内能其中，分子平均平动动能和气温有直接关系。【公式2】微观量只和气温和分子类型有关。所以研究气体，最重要的是研究宏观。气温、气压、气浓知二求一。【公式1】然后知道方均根速率和分子平均平动动能的关系。【公式4】单位体积内能只与温度和分子数有关。 第18章 热力学第一定律 热力学第一定律Q、A、EQ=$\DeltaE+A$，主要记文字表述：系统吸热等于系统内能增量+系统对外做功【Q的确定依赖T】【A的确定依赖PV】【E的确定依赖VT】热力学第一定律问题本质上是对气体宏观属性的利用。 准静态过程体积功A、P、V$A=\int^{V_2}_{V_1}p{\rm d}v$在PV图里，正向面积为系统对外做功，负向面积为外界对内做功。循环过程中，顺时针是整体对外做功，逆时针是整体外界对内做功。体积功正负只和体积变化有关，体积变大一定对外做功，体积缩小一定对内做功。 热容定体热容$C_{V,m}=\frac{i}{2}R$定压热容$C_{P,m}=\frac{i+2}{2}R$ 几种过程等体过程，A=0等压过程等温过程，$\DeltaE$=0绝热过程，Q=0$PV^γ=const$,γ是比热比。$A=\frac{1}{γ-1}(P_1V_1-P_2V_2)$ 绝热自由膨胀（不是准静态过程）写不动了，回头在更新]]></content>
      <tags>
        <tag>大物</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[复变函数论]]></title>
    <url>%2Funln1999.github.io%2F2019%2F09%2F22%2Ffb1%2F</url>
    <content type="text"><![CDATA[本教程不是零基础向，读者应有高中复数基本知识等。 1.1 复数、区域和边界1.1.1 复数的基本定义常识。a+bi中，a是实部，b是虚部，提取实部虚部的记号要记住，是Re z和Im z加减乘除的共轭要会算。 1.1.2 复数的几何表示与各种标记就是在复平面上用向量表示复数。长度称为复数的模。辐角主值是最常用的，辐角有无穷个。（z=0时，辐角没有意义） 然后复数除了代数式，还可以写成三角式，和利用欧拉公式写成指数式。（虽然指数式不是记号，而是确实等于这个复数，但也可以把它作为一种记号，便于理解，看不懂这句话就算了……） 复数的加减用代数式或向量式（本质是一个东西）。复数的乘除用指数式（或三角式）。开方也用指数式，开几次方，有几个解. 1.1.3 球极投影了解 1.1.4区域和边界区域是连通的开集。边界也是常识，边界由边界点构成，边界点的任意邻域内，既有属于区域的点也有区域外的点。边界和区域的并集为闭区域。 1.2 复变函数本课程内，我们只研究单值函数。复变函数类似于二元函数。只不过是两个二元函数的“复合”。多元函数的极限，需要不依赖路径，复变函数也是如此。复变函数有极限，需要两个二元函数都有极限。复变函数的连续也等价于两个二元函数的连续。但是复变函数本质上又是一元函数。差不多就这样。 1.3 复变函数的可微性和解析性可微是对点来说的，其实也可以对整个函数来说，只不过这里整个单值函数可微称为解析。作为一元函数，复变函数可导等价于可微。需要记忆的↓柯西黎曼条件：$\frac{\patialu}{patialx}=\frac{\patialv}{patialy},\frac{patialu}{patialy}=-\frac{\patialv}{patialx}$拉普拉斯微分方程：调和函数满足：$\frac{\patial^2\phi}{patialx^2}+\frac{\patial^2\phi}{patialy^2}$]]></content>
      <tags>
        <tag>复变</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bugku 2019-9-21 web2]]></title>
    <url>%2Funln1999.github.io%2F2019%2F09%2F21%2Fbk3-web2%2F</url>
    <content type="text"><![CDATA[进入题目页面出现了一堆滑稽，看起来没什么线索，但是能猜到设计者的坏心思。 思路web题首先给我们的是一个页面，页面和html在某种意义上是等效的，但是并不是所有的html语言都会被浏览器显示出来。因此，html代码比页面富含更多的信息（页面只不过更加具体形象）。所以如果在页面找不到线索，就按F12查看一下html代码。 writeup打开开发者工具（F12），出现了醒目的flag。 知识点 Html代码的查看]]></content>
      <tags>
        <tag>bugku</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[半导体二极管及其基本应用电路——模电Charpter2]]></title>
    <url>%2Funln1999.github.io%2F2019%2F09%2F21%2Fmd2%2F</url>
    <content type="text"><![CDATA[写在最最前面模电第一章是绪论，所以第一章不做笔记。然后本套笔记的标题为“章.节.点”，一般省略章。标题主要取自哈尔滨工业大学的慕课《模拟电子技术基础》，次取自高等教育出版社的《模拟电子技术基础》。也会有自己添加标题的情况。本笔记主要标记方式为加粗、下划线和红蓝字体。重点程度为，红&gt;蓝&gt;加粗，下划线是需要理解记忆（或强行记忆）的地方。本笔记不宜作为自学、系统学习的教程。主要是个人向的重点总结。没了，好好学习！ 1 半导体基本知识和PN结1.1 半导体基础知识本征半导体光热下本征激发和复合动态平衡，产生少量载流子。 杂质半导体P型：多数载流子是空穴，掺入了三价原子。N型：多数载流子是电子，掺入了五价原子。杂质半导体的载流子是自由电子和空穴。 1.2 PN结扩散运动多子因为浓度差开始扩散，形成了耗尽层（空间电荷区、势垒区）。浓度差始终存在，因此扩散始终进行。 漂移运动耗尽层中，形成内电场，使得内电场中的少子开始漂移削弱内电场。内电场始终存在，因此漂移始终进行。 动态平衡扩散增强内电场，漂移削弱内电场，哪个作用强，哪个作用就会减弱，另一个的作用就会增强，最终达到动态平衡，内电场强度宏观上不再变化。 单向导电性正向偏置导电有压降，反向偏置截止。 电容效应了解2 半导体二极管2.1 二极管的伏安特性硅：0.5V 0.7V锗：0.1V 0.3V 2.2 二极管的等效模型 理想模型 恒压降模型 折线化模型 小信号模型]]></content>
      <tags>
        <tag>模电</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bugku 2019-9-20 web基础$_POST]]></title>
    <url>%2Funln1999.github.io%2F2019%2F09%2F20%2Fbk2-post%2F</url>
    <content type="text"><![CDATA[进入题目页面显示 1234$what=$_POST[&apos;what&apos;];echo $what;if($what==&apos;flag&apos;)echo &apos;flag&#123;****&#125;&apos;; 思路阅读后，知道这是php代码，意思是，用post方式从html里获取一个名为’what’的表单值赋给php的变量＄what。然后页面会打印出＄what变量的值。当＄what为’flag’时，还会输出flag。这段代码显然不是后台实际脚本，只是一个提示。根据该提示，我们提交一个＄what变量。 writeup解法1用firefox的hackbar插件（日后写一个免费hackbar的教程）提交。然后点击Execute就可以传递了。 解法2打开bp，刷新页面这段文字是 123456789GET /post/ HTTP/1.1Host: 123.206.87.240:8002User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:69.0) Gecko/20100101 Firefox/69.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateConnection: closeUpgrade-Insecure-Requests: 1Cache-Control: max-age=0 （注，下面的操作也推荐在repeater里进行）把第一行的GET改成POST，把前两行之外的内容全删除。添加一行：Content-Type: application/x-www-form-urlencoded【背诵】然后再空一行并添加一行：what=flag。如下图（必须要空一行，如箭头所示）：注意flag后面不能有空格，因此要用delete清除后面的空格、空行。然后提交包，页面显示flag。 知识点 如何提交post变量 php代码阅读（基础）]]></content>
      <tags>
        <tag>bugku</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP教程 of RUNOOB]]></title>
    <url>%2Funln1999.github.io%2F2019%2F09%2F19%2F11php%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[本文将以我个人的视角简单叙述。本文不是零基础的，读者应有任何一门普通高级编程语言的基础学习经验。 简介建议先学一定的HTML和CSS， PHP是什么一种后端脚本语言。 PHP文件是什么包含文本、HTML、JS、PHP代码的文件，在服务器上执行，以纯HTML的形式返回给浏览器 PHP的功能简单地说，可以处理服务器上的文件、收集表单数据、收发cookies、处理数据库、限制用户访问、加密。 安装安装LAMP或LNMP就行。LAMP安装本博客已有教程。 基本语法起始PHP脚本以结尾。类似于： 123&lt;?php content;?&gt; 代码行PHP脚本中的一行行内容就是代码行，代码行以分号作结。 注释和c语言一样。然后还有井号注释。 变量PHP变量变量是什么就不多说了，PHP变量的特点是加了dollar符——$。变量命名规则也不多说了，基本常规的就行。主要不是自己写，而是看得懂。PHP是弱类型语言。 变量作用域 local global static parameter local就是局部变量，在一个函数内部声明。global是全局变量，在所有函数之外声明，在函数中调用（比如一个名为$x的变量）需要在函数中加关键字声明同样的变量： 1global $x;]]></content>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bugku 2019-9-19 web基础$_GET]]></title>
    <url>%2Funln1999.github.io%2F2019%2F09%2F19%2Fbk1-get%2F</url>
    <content type="text"><![CDATA[进入题目页面显示 1234$what=$_GET[&apos;what&apos;];echo $what;if($what==&apos;flag&apos;)echo &apos;flag&#123;****&#125;&apos;; 思路阅读后，知道这是php代码，意思是，用get方式从html里获取一个名为’what’的表单值赋给php的变量＄what。然后页面会打印出＄what变量的值。当＄what为’flag’时，还会输出flag。这段代码显然不是后台实际脚本，只是一个提示。根据该提示，我们让浏览器用get方式提交一个what变量值，这只需要通过url实现。 writeup直接在浏览器url后添加’?what=flag’然后有： 知识点 如何提交get变量 php代码阅读（基础）]]></content>
      <tags>
        <tag>bugku</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux小笔记——vim编辑]]></title>
    <url>%2Funln1999.github.io%2F2019%2F09%2F18%2F10vim%2F</url>
    <content type="text"><![CDATA[编辑模式 按i 在光标处插入 I 在头插入 按a 在光标后一位插入 A 在尾插入 按o 在下一行开始输入 O 在上一行开始输入 按r 取代一次 R 一直取代 命令模式 w 保存 w！ 强行保存只读文件 q 退出 q！ 强制退出 wq 保存并退出 e！ 还原回初始状态 w[filename] 另存为 r[filename] 读入 set nu 显示行号 set nonu 取消行号 n1 n2 w[filename] 另存n1到n2行的内容 ！command 暂时离开vim执行linux命令]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux小笔记——文件权限、用户权限]]></title>
    <url>%2Funln1999.github.io%2F2019%2F09%2F18%2F9linux%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[Linux用户对文件的权限主要有三种，读、写、执行。分别是r、w、x。也就是read、write、execute。 Linux用户关于文件权限的三个命令分别是ls、chmod、chown。 ls下面我挑了几个我个人觉得有用的选项-a 显示隐藏的文件（试了一下，-A好像和-a差不多，就是少了.和..）-l 单列显示，并且很详细-F 在文件名后显示类型标识符-b 用编码显示不可输出的字符-d 仅显示目录名-k 以KB显示文件大小（感觉没啥用）-m 加逗号分隔文件和目录-r 反向排序-s size，也是显示大小-t time，按更改时间排序-R 递归处理（在目录里继续lS） chmod字母模式chomod [ugoa][+-=][rexX] -R 递归-f 抑制失败错误信息数字模式ugo各一个数字r1w2x4 比如715u的权限是rwxg的权限是ro的权限是rx chownchomod id:idgroup 给用户sudo权限123$ su(输入密码)# vim /etc/sudoers 然后找到“root ALL=(ALL)ALL”这一行，然后再下一行添加：“你要赋予权限的用户名 ALL=（ALL）ALL”比如“zhanhan ALL=(ALL)ALL”]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS换中科大源【web系列4】]]></title>
    <url>%2Funln1999.github.io%2F2019%2F09%2F16%2F7.%E6%8D%A2%E6%BA%90%2F</url>
    <content type="text"><![CDATA[首先备份源。然后编辑源。备份过程略。首先提供编辑权限，一时半会不用改回去。 1234# cd /etc/yum.repos.d/# touch epel.repo# touch epel-testing.repo# chmod a+rwx -R /etc/yum.repos.d/ 然后在文件夹里打开到这个目录，编辑。个人觉得比vim方便。编辑CentOS-Base.repo: 123456789101112131415161718192021222324252627282930313233343536373839# CentOS-Base.repo## The mirror system uses the connecting IP address of the client and the# update status of each mirror to pick mirrors that are updated to and# geographically close to the client. You should use this for CentOS updates# unless you are manually picking other mirrors.## If the mirrorlist= does not work for you, as a fall back you can try the# remarked out baseurl= line instead.##[base]name=CentOS-$releasever - Base#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=osbaseurl=http://mirrors.ustc.edu.cn/centos/$releasever/os/$basearch/gpgcheck=1gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7#released updates[updates]name=CentOS-$releasever - Updates# mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=updatesbaseurl=http://mirrors.ustc.edu.cn/centos/$releasever/updates/$basearch/gpgcheck=1gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7#additional packages that may be useful[extras]name=CentOS-$releasever - Extras# mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=extrasbaseurl=http://mirrors.ustc.edu.cn/centos/$releasever/extras/$basearch/gpgcheck=1gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7#additional packages that extend functionality of existing packages[centosplus]name=CentOS-$releasever - Plus# mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=centosplusbaseurl=http://mirrors.ustc.edu.cn/centos/$releasever/centosplus/$basearch/gpgcheck=1enabled=0gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7 编辑epel.repo: 123456789101112131415161718192021222324[epel]name=Extra Packages for Enterprise Linux 7 - $basearchbaseurl=http://mirrors.ustc.edu.cn/epel/7/$basearch#mirrorlist=https://mirrors.fedoraproject.org/metalink?repo=epel-7&amp;arch=$basearchfailovermethod=priorityenabled=1gpgcheck=1gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-7[epel-debuginfo]name=Extra Packages for Enterprise Linux 7 - $basearch - Debugbaseurl=http://mirrors.ustc.edu.cn/epel/7/$basearch/debug#mirrorlist=https://mirrors.fedoraproject.org/metalink?repo=epel-debug-7&amp;arch=$basearchfailovermethod=priorityenabled=0gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-7gpgcheck=1[epel-source]name=Extra Packages for Enterprise Linux 7 - $basearch - Sourcebaseurl=http://mirrors.ustc.edu.cn/epel/7/SRPMS#mirrorlist=https://mirrors.fedoraproject.org/metalink?repo=epel-source-7&amp;arch=$basearchfailovermethod=priorityenabled=0gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-7gpgcheck=1 编辑epel-testing.repo: 123456789101112131415161718192021222324[epel-testing]name=Extra Packages for Enterprise Linux 7 - Testing - $basearchbaseurl=http://mirrors.ustc.edu.cn/epel/testing/7/$basearch#mirrorlist=https://mirrors.fedoraproject.org/metalink?repo=testing-epel7&amp;arch=$basearchfailovermethod=priorityenabled=0gpgcheck=1gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-7[epel-testing-debuginfo]name=Extra Packages for Enterprise Linux 7 - Testing - $basearch - Debugbaseurl=http://mirrors.ustc.edu.cn/epel/testing/7/$basearch/debug#mirrorlist=https://mirrors.fedoraproject.org/metalink?repo=testing-debug-epel7&amp;arch=$basearchfailovermethod=priorityenabled=0gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-7gpgcheck=1[epel-testing-source]name=Extra Packages for Enterprise Linux 7 - Testing - $basearch - Sourcebaseurl=http://mirrors.ustc.edu.cn/epel/testing/7/SRPMS#mirrorlist=https://mirrors.fedoraproject.org/metalink?repo=testing-source-epel7&amp;arch=$basearchfailovermethod=priorityenabled=0gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-7gpgcheck=1 接着要补充一个gpg密钥文件。 12# cd /etc/pki/rpm-gpg # wget https://archive.fedoraproject.org/pub/epel/RPM-GPG-KEY-EPEL-7 然后应该就完事了。]]></content>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux中的DVWA环境搭建【web系列5】]]></title>
    <url>%2Funln1999.github.io%2F2019%2F09%2F16%2F8%2F</url>
    <content type="text"><![CDATA[下载DVWA我用的系统是CentOS 7。预先要安装好LAMP环境【参考web系列3】。在DVWA官网点击Download下载DVWA环境（其实是有版本的）。 解压zip文件然后用VMware Tools复制到虚拟机中，当然直接在虚拟机里下载也行。先su一下，然后改一下目录的读写权限（我感觉改了之后很方便） 1# chmod a+rwx -R /var/www/ 然后直接把压缩包放到这个目录里。（也可以在其它目录解压到这个目录） 1234[root@localhost html]# unzip DVWA-master.zip [root@localhost html]# rm DVWA-master.zip rm：是否删除普通文件 &quot;DVWA-master.zip&quot;？y[root@localhost html]# mv DVWA-master/ DVWA 解压并删除压缩包。把目录名字修改为DVWA有必要的话，还需要多次赋予读写权限。 配置config12[root@localhost html]# cd DVWA/config[root@localhost config]# cp config.inc.php.dist config.inc.php #备份 这里就是需要config文件，备份的同时，把dist去掉，php文件作为config文件（配置文件）。编辑这个php文件，把server改为localhost，把password修改为root。 使用DVWA然后在浏览器里输入：“localhost/DVWA”就可以进入类似于下图的DVWA界面。点击Create/Reset Database后会创建数据库。然后就会跳转到登录界面。之后都会直接是登录界面。初始用户名是admin，密码是password。登录后是这样的，安装成功~]]></content>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS 7（Gnome桌面）安装流程【web系列1】]]></title>
    <url>%2Funln1999.github.io%2F2019%2F09%2F15%2F4centos%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[安装好的CentOS出了点问题（加之之前设置错了），而且我还把镜像文件删了（我怀疑是因为这个原因导致Gnome桌面加载不出来），因此打算重新安装一遍，顺便写一下技术文档！ 预先安装VMware Workstation Pro 15因为我事先安装好了，所以暂时先不记录流程。这个东东是用固定序列号注册的，所以正版激活只用百度序列号。之后我会写一篇文章来讲Vmware Workstation的安装。 下载CentOS镜像文件在这个页面下载DVD ISO文件。然后等下好。 创建虚拟机1.打开VMware Workstation。点击创建虚拟机（在左上角“文件”菜单里有）。2.选择自定义！！！下一步。3.下一步。4.选择默认的“安装程序光盘映像文件”，然后在你下载好的镜像文件存放目录里选择iso文件。（不要有中文目录！！！，虽然我第一次安装也有中文目录且没有什么问题）下一步。5.下一步。6.下一步。（内核数量改成2也行）7.下一步。（内存改成2G也行）8.下一步。（选择NAT）9.下一步。（LSI logic）10.下一步。（SCSI）11.下一步。（创建新虚拟硬盘）12.下一步。（20G，拆分成多个文件）13.下一步。14.下一步。（可以勾选创建后开启此虚拟机，我勾选了。） 虚拟机安装1.启动虚拟机后，选择Install centos（画面过去了，我不记得是不是叫这个了，总之有个目录，选择第一个带install的就行。）2.鼠标移动到画面内，按下Enter键。3.进入一个图形界面后选择安装语言（这个语言是安装过程中的语言），如果没有特殊需求，选用中文。4.然后会有这样的界面。在第一个本地化的设置里什么都不用修改（当然前提是和图中一样）在软件里面，修改“软件选择”，如果是最小安装的话，会只有命令行，并缺少很多常用的东西。按下图，左边选择GNOME桌面，右边选择图中这四个。5.点击系统里面的“安装位置”，什么也不用修改，确认。6.接着点下面的“网络与主机名”，把以太网开关打开，否则无法联网。7.接着点击“开始安装”，这里要设定用户名和密码，边安装边设置就行。密码建议别太长(不过我还是设置的很长)。图中这里勾上把此用户作为管理员！！！8.等待安装完成后，重启。9.重启后点击Licence Infomation，然后再点同意，确认。10.点击右下角完成配置。11.然后进入图形化登录界面。12.登陆后配置语言、输入法。在线账号那里可以跳过。13.然后就安装完毕了。 关于VMware Tools安装很重要的工具，把真实系统和虚拟机联系起来，并且可以调整虚拟机的画面大小啥的。我之前装过了……然后重装系统之后还有，迷惑。我看在Ubuntu系统上安装的时候，单独写一篇日志。]]></content>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LAMP环境安装【web系列3】]]></title>
    <url>%2Funln1999.github.io%2F2019%2F09%2F15%2F6.LAMP%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[蓝色字体将介绍安装的软件。 环境检测全新系统不需要这一步，我暂时跳过，日后补充。 安装Apache、PHP、Mysql1.安装Apache世界使用排名第一的服务器软件，可广泛地运行于多个平台上先su进root。 1# yum -y install httpd 我的返回结果是： 1234567已安装: httpd.x86_64 0:2.4.6-89.el7.centos.1 作为依赖被安装: httpd-tools.x86_64 0:2.4.6-89.el7.centos.1 mailcap.noarch 0:2.1.41-2.el7 完毕！ 2.安装PHP一种较新的web脚本语言，php环境用来运行php程序代码输入： 1# yum -y install php 我的返回结果是： 12345678已安装: php.x86_64 0:5.4.16-46.el7 作为依赖被安装: libzip.x86_64 0:0.10.1-8.el7 php-cli.x86_64 0:5.4.16-46.el7 php-common.x86_64 0:5.4.16-46.el7 完毕！ 3.安装php-fpmphp的fastCGI process manager，CGI是通用网关接口（Common Gateway Interface）,fast就是快速。web服务器（我们的是Apache）本身不能解释php语言，服务器将php请求交给FastCGI进程管理来处理。对于5.3.3之前的php环境，应该只有安装了php-fpm，才能让服务器解释php文件。我的php版本为5.4.16，我特意卸载掉php-fpm依然可以在localhost里打开php文件。输入： 1# yum -y install php-fpm 我的返回结果是： 1234已安装: php-fpm.x86_64 0:5.4.16-46.el7 完毕！ 4.安装Mysql一种流行的DBMS（关系型数据库管理系统）输入： 1# yum -y install mysql 我的返回结果是： 1234已安装: mariadb.x86_64 1:5.5.60-1.el7_5 完毕！ 5.安装Mysql-serverMysql的服务器，是Mysql的核心程序这一步要先换源！！！【参考web系列4】这里用yum会出错，这是作者怕Mysql闭源的结果。无法使用下面的命令： 1# yum -y install mysql-server 直接从官网下载Mysql-server就可以了输入： 123# wget http://dev.mysql.com/get/mysql-community-release-el7-5.noarch.rpm #这个命令我用的时候有问题，也可以直接在windows里输入后半部分URL，然后用VMware Tools弄到CentOS主文件夹里。可能是少了-i# rpm -ivh mysql-community-release-el7-5.noarch.rpm2# yum install mysql-community-server 输入y继续。耐心等候。（这个过程很快，如果不快就换源，阿里云的好像不行，中科大的快）我的返回结果是： 123456789101112已安装: mysql-community-server.x86_64 0:5.6.45-2.el7 作为依赖被安装: perl-Compress-Raw-Bzip2.x86_64 0:2.061-3.el7 perl-Compress-Raw-Zlib.x86_64 1:2.061-4.el7 perl-DBI.x86_64 0:1.627-4.el7 perl-IO-Compress.noarch 0:2.061-2.el7 perl-Net-Daemon.noarch 0:0.48-5.el7 perl-PlRPC.noarch 0:0.2020-14.el7 完毕！ 6.安装php-mysql应该是php和Mysql的接口工具之类的（百度不到）输入： 1# yum -y install php-mysql 我的返回结果是： 1234567已安装: php-mysql.x86_64 0:5.4.16-46.el7 作为依赖被安装: php-pdo.x86_64 0:5.4.16-46.el7 完毕！ 安装基本常用扩展包1.安装Apache扩展包输入： 1# yum -y install httpd-manual mod_ssl mod_perl mod_auth_mysql 我的返回结果是： 1234567891011121314151617已安装: httpd-manual.noarch 0:2.4.6-89.el7.centos.1 mod_perl.x86_64 0:2.0.10-3.el7 mod_ssl.x86_64 1:2.4.6-89.el7.centos.1 作为依赖被安装: gdbm-devel.x86_64 0:1.10-8.el7 libdb-devel.x86_64 0:5.3.21-24.el7 perl-BSD-Resource.x86_64 0:1.29.07-1.el7 perl-ExtUtils-Install.noarch 0:1.58-294.el7_6 perl-ExtUtils-MakeMaker.noarch 0:6.68-3.el7 perl-ExtUtils-Manifest.noarch 0:1.61-244.el7 perl-ExtUtils-ParseXS.noarch 1:3.18-3.el7 perl-Linux-Pid.x86_64 0:0.04-18.el7 perl-devel.x86_64 4:5.16.3-294.el7_6 systemtap-sdt-devel.x86_64 0:3.3-3.el7 完毕！ 2.安装PHP扩展包输入： 1# yum -y install php-gd php-xml php-mbstring php-ldap php-pear php-xmlrpc php-devel 我的返回结果是： 1234567891011已安装: php-devel.x86_64 0:5.4.16-46.el7 php-gd.x86_64 0:5.4.16-46.el7 php-ldap.x86_64 0:5.4.16-46.el7 php-mbstring.x86_64 0:5.4.16-46.el7 php-pear.noarch 1:1.9.4-21.el7 php-xml.x86_64 0:5.4.16-46.el7 php-xmlrpc.x86_64 0:5.4.16-46.el7 作为依赖被安装: pcre-devel.x86_64 0:8.32-17.el7 php-process.x86_64 0:5.4.16-46.el7 t1lib.x86_64 0:5.1.2-14.el7 完毕！ 3.安装Mysql扩展包输入： 1# yum -y install mysql-connector-odbc mysql-devel libdbi-dbd-mysql 我的返回结果是： 12345678910已安装: libdbi-dbd-mysql.x86_64 0:0.8.3-16.el7 mysql-community-devel.x86_64 0:5.6.45-2.el7 mysql-connector-odbc.x86_64 0:8.0.17-1.el7 作为依赖被安装: libdbi.x86_64 0:0.8.4-6.el7 libdbi-drivers.x86_64 0:0.8.3-16.el7 unixODBC.x86_64 0:2.3.1-11.el7 完毕！ 配置Apache、Mysql开机启动（这样更方便）123456# systemctl enable httpd.service #设置apache开机启动(返回如下)Created symlink from /etc/systemd/system/multi-user.target.wants/httpd.service to /usr/lib/systemd/system/httpd.service.# systemctl enable mysqld.service #设置mysql开机启动（没有返回结果） 重启检验是否开机启动 12# service mysqld status# service httpd status 配置Mysql设置密码输入： 12345# mysql_secure_installation（回车）（回车）（输入密码，不显示，我输入的是root）（回车4次，完成设置） 测试环境测试Apache在虚拟机的浏览器（firefox）里打开“http://localhost/”应该会如图有这样的界面，如果没有说明有问题，或者apache没有启动。没有启动要用 12# service httpd status #确定是否启动# service httpd start #启动 测试php123# cd /var/www/html# touch phpinfo-test.php #这个名字无所谓的# vim phpinfo-test.php 写一个简单的php文件： 123&lt;?phpphpinfo;?&gt; 然后保存退出，浏览器力打开“localhost/phpinfo-test.php”如果出现下图，则php安装成功。]]></content>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu18.04.3安装流程【web系列2】]]></title>
    <url>%2Funln1999.github.io%2F2019%2F09%2F15%2F5ubuntu%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[预先安装VMware Workstation Pro 15因为我事先安装好了，所以暂时先不记录流程。这个东东是用固定序列号注册的，所以正版激活只用百度序列号。之后我会写一篇文章来讲Vmware Workstation的安装。 下载Ubuntu镜像文件在这个页面下载Ubuntu Desktop latest（LTS） 创建虚拟机1.打开VMware Workstation。点击创建虚拟机（在左上角“文件”菜单里有）。2.选择自定义！！！下一步。3.下一步。4.选择稍后安装操作系统下一步。5.然后选择Linux，下面选择Ubuntu 64位，放张图，更直观。下一步。6.然后可以改一下系统名字，安装目录建议不选系统盘（我CentOS又装错了，C盘好像占用了很多空间，一会儿再重装一次……）下一步。7.下一步。（1个内核就行）8.下一步。（2G就行）9.下一步。（NAT）10.下一步。（LSI logic）11.下一步。（SCSI）12.下一步。（创建新虚拟硬盘）13.我看到教程改成了拆分成单个文件，我们不拆。直接下一步。14.下一步。15.完成。 虚拟机安装1.按图配置ISO文件。(最后⑤的圈没圈起来)2.启动虚拟机，如果有问题，重新下载ISO文件。3.过一段时间进入安装界面，选择中文，并点击安装Ubuntu。4.之后几步一直按默认来，点击继续，直到设置用户名和密码。5.输入用户名和密码，然后选择自动登录，方便。6.然后等待安装，安装完成后重启。检查一下网络连接。如果无法进入桌面（一直黑屏）重启虚拟机，马上按E，然后进入一个有四个选项的紫色界面，在第一个选项“ubuntu”上按一次E，然后进入一个编辑界面，有点像vim。然后找到一个splash，在后面打一个空格，然后输入nomodeset。再按ctrl+X重启。 VMware Tools安装在左上角“虚拟机”菜单里点击安装VMware Tools。然后桌面会有一个光盘的图标，双击打开。复制里面的压缩包到主目录。压缩包就是下图圈的那个。然后打开终端。这里介绍一下ubuntu su进root的办法，挺重要的。就是ubuntu为了安全性，不允许su进root，但是对于服务器来说，管理员模式很重要。su进root只需要： 1234$ sudo passwd (输入原密码)（输入新密码，可以和原密码一样，建议一样）（确认新密码） 搞定之后就可以su进root了。接着我们继续 123# tar -zxvf VMware Tools-版本号.tar.gz #这里只需要输入一个V，然后按Tab键补齐就行。# cd vmware-tools-distrib# sudo ./vmware-install.pl 然后重启就可以使用VMware Tools了。重启的时候又黑屏，估计每次都得搞那个nomodeset。]]></content>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[时域分析]]></title>
    <url>%2Funln1999.github.io%2F2019%2F09%2F13%2F3%E7%94%B5%E8%B7%AF%E6%97%B6%E5%9F%9F%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[小结1.动态元件电感电容这类其上电压电流呈导数关系的元件。 2.稳态电路量为常量或周期量的电路工作状态称为稳态。 3.换路改变电路工作状态的因素。 4.暂态动态元件吸收或释放元件的过渡过程就是暂态。 5.时域分析的思想暂态过程是一段时间，这段时间上，电路量发生改变，而这些电路量的改变可以用关于时间的函数来刻画。因此，利用电路结构方程和欧姆定律以及动态元件端口特性方程，我们可以列写以t为因变量的微分方程。主要是简单的一阶微分方程，可以套用公式来解。为了得到唯一解，还需要确定初始条件。初始条件的确定利用换路定律和直流电路分析（把换路瞬间认为是直流，并且对动态元件使用置换定理）。【判断符号时，变化量是增大还是减小，根据实际情况确定】 6.初始值的确定第五点里已经提到了，很简单。 7.一阶电路的零输入响应RC电路零输入响应（与其说是响应，不如说是各种电路量）最终解得 $u_C=U_0e^{-\frac{t}{RC}}$ $i_C=\frac{U_0}{R}e^{-\frac{t}{RC}}$ $u_R$就不用说了。 时间参数$\tau$为$RC$这种类型的电路，在变路时，电容放电，产生较大放电电流。 GL电路零输入响应最终解得 $i_L=I_0e^{-\frac{Rt}{L}}$ $u_L=-RI_0e^{-\frac{Rt}{L}}$ $i_R$就不用说了。 时间参数$\tau$为$\frac{L}{R}$这种类型的电路，在变路时，电感释放磁场，产生较大电场，也即产生较大电动势。断开含高阻值电阻的电感电路时，开关上可能会形成巨大的电压，因此要减小等效电阻再切断电路，以免发生危险。 8.阶跃函数$\varepsilon(t)$就是单位阶跃函数。$\varepsilon(t-t_0)$是延迟单位阶跃函数$\varepsilon(t)-\varepsilon(t-t_0)$是一种矩形脉冲。也记作$G(t)$。$tG(t)$是一种锯齿形脉冲。 9.冲激函数冲激函数是一种作用时间很短的脉冲信号，但是它具有脉冲强度。是一种奇异函数。单位冲激函数记作$\delta(t)$，其脉冲强度为1。$K\delta(t)$是一般的冲激函数，K的单位是库伦或者韦伯。动态元件的快速变化可以视为一个一般冲激函数。这种变化中，换路定律将不再成立。（这种很快的变化是理想的，实际中不存在），换句话说，暂态过程也非常快，几乎认为不需要时间。 10.一阶电路的阶跃响应我们讨论的阶跃响应是零状态响应。我们列出的微分方程为一阶非齐次微分方程。 特解特解是稳态分量 齐次方程通解$u_C=-Ae^{\frac{t}{RC}}$齐次方程通解是暂态分量 通解$U_C=U_S(1-e^{\frac{t}{RC}})\varepsilon(t)$$i_C=\frac{U_S}{R}e^{\frac{t}{RC}}$ 单位阶跃特性$s(t)=\frac{u_C(t)}{U_S}=(1-e^{\frac{t}{RC}})\varepsilon(t)$ 所以通解为$U_Ss(t)$ 11.一阶电路的冲激响应设$u_S$是宽度为$\Delta\xi$，幅度为$\Psi/\Delta\xi$的矩形脉冲电压。拆解为两个幅度为$\Psi/\Delta\xi$的阶跃电压的叠加。$u_S=u_S’+u_S’’=\frac{\Psi}{\Delta\xi}(\varepsilon(t)-\varepsilon(t-\Delta\xi)$再用阶跃特性计算响应。有：$u_C=\frac{\Psi}{\Delta\xi}(s(t)-s(t-\Delta\xi))$又因为$\Delta\xi$趋于0，所以，$u_C=\Psi\frac{ds(t)}{dt}$$u_C=Ue^{\frac{t}{\tau}\varepsilon(t)}$i_C=$[Q\delta(t)-\frac{U}{R}]e^{\frac{t}{\tau}}$冲激响应的初始值不适用于换路定律，因为是奇异函数。类似于零输入响应 单位冲激特性$h(t)=\frac{ds(t)}{dt}$ 12.正弦电源作用下的一阶电路$u_S=U_mcos(\omegat+\Psi_u)$$\Psi_u$是开关接通时刻电源的相位，称为接入相角。首先确定稳态解，直接把正弦电压向量除以阻抗就好了。然后求齐次方程通解，为$Ae^{-\frac{t}{\tau}}$，A是积分常数。接下来利用初始值确定积分常数，A为特解在0+时的负值。【当$\Psi_u-\phi=\frac{\pi}{2}或-\frac{\pi}{2}时没有暂态$】【当$\Psi_u-\phi=\pi或-\pi，会产生较大响应，电气设备要注意防范。$】 13.一阶电路的全响应一阶电路的全响应可以分为零输入响应和零状态响应。]]></content>
      <tags>
        <tag>电路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Win10利用Github+Hexo建个人博客]]></title>
    <url>%2Funln1999.github.io%2F2019%2F09%2F12%2F1%E5%BB%BA%E7%AB%8B%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[任何已完成的步骤可以跳过。参考的主要原文点击 这里、这里（推荐）和这里【但是我认为里面会有一些错误，所以尽量以本文为主】 1.注册Github账号这个环节非常简单，只需要打开Github官网，然后在右上角的sign up处注册就可以了。在第一个环节有个小测试（来测试你是否是机器人、AI、程序啥的），有时候浏览器可能无法加载，这个时候可以尝试用手机浏览器解决。根据实践，苹果自带的safari是可以完成注册的。 2.创建Github仓库在Github首页（或许包括绝大多数页面）可以找到New Repository按钮，Repository就是仓库。仓库名称为你的用户名.github.io。用户名就是你注册设置的那个玩意儿。我的用户名是unln1999，可能你不知道它是什么意思，反正这就是我的用户名。那么我的仓库名就是unln1999.github.io。【应该是可以设置为其它名字的，但是不建议第一次就特立独行，Github大佬自行设置qaq】选择类型为Public，如果是Private就无法成为一个大家都能看到的网站了（大概是这样）其它设置不需要变，点击Create Repository按钮即可。 3.安装Git在Git官网的下载页面直接下载你对应系统的Git，这里以windows系统为例。一般打开这个页面应该能够看到一个显示器的图像，点击里面的那个按钮“Download 版本号 for windows”就可以下载安装包了。然后在本地双击安装包，一直按默认设置点下一步即可。（当然大佬可以自己配置）装好之后，在任何文件夹（包括桌面）右键都可以使用Git Bash终端了 4.安装Nodejs在Nodejs官网的下载页面直接下载你对应系统的对应位数（目前一般是64位）的.msi安装包。然后在本地双击安装包，在下图的界面里选择Add to PATH，然后接下来只用一直点击下一步即可。（之前我自己变动了一个选项，导致没装好，重新装了一次，所以建议不改默认配置） 5.安装HEXO在Git Bash里输入 1$ npm install -g hexo-cli 就会开始安装HEXO，安装过程会有点慢，如果你中途想要关闭终端，它会提示正在工作，因为Git Bash有时候（就我目前使用来看）不会显示进程详情，所以只能通过右上角点关闭来判断终端是否在工作。耐心等待，HEXO就安装好了。可以输入HEXO -v确定是否安装完毕。 6.创建博客在本地选择一个合适的目录，比如我选在了D:\博客环境。然后再这个目录下右键Git Bash Here。输入 1234$ hexo init 你的用户名.github.io #创建博客$ cd 你的用户名.github.io #进入该目录$ git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia #下载yilia主题，也可以用别的主题，自行百度hexo主题$ npm install hexo-deployer-git --save #安装hexo自动部署发布工具，有了这个才能部署，所谓部署就是上传到Github上 在资源管理器（也就是常说的文件浏览器什么的）中进入博客目录（比如我的D:\博客环境\unln1999.github.io）,然后用编辑器（推荐notepad++）打开_config.yml。进行一些基本设置，以下是一些基本的设置项，我用我的设置作为参考 基本设置12345678# Sitetitle: 夢の此夜亭🌸 #博客的名称，类似于网页名称subtitle: A Blog with Tiny Fantasy #副标题description: 记录CTF学习之路上的各种收获，和同学们分享，共同进步~ #这个好像不显示，写不写也无所谓keywords: #不懂，空着先author: 英和路雪 #作者名，其实无所谓，随便填language: zh-Hans #汉语，这个应该比较重要timezone: Asia/Shanghai #时区 主题设置（选择刚才下的yilia或者你自己下的主题）1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: yilia 重要设置（这里的设置网上有很多种，按我的来吧）12345678910111213# URL## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: https://unln1999.github.io/unln1999.github.io #这个是真实URL，也就是说你在网页里输入unln1999.github.io就可以访问博客了root: /unln1999.github.io/ #这个是根目录，也就是你本地的文件夹名，刚开始我们创建博客用的文件夹名是和网址相同的（D:\博客环境\unln1999.github.io），如果取的名字是别的，比如blog，那么这里是/blog/，url也要改为https://unln1999.github.io/blogpermalink: :year/:month/:day/:title/permalink_defaults:# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git #这里应该必须设置为git，不能设置为github之类的 repository: https://github.com/unln1999/unln1999.github.io.git #注意结尾是.git，这里参考网址2里说的我认为有误 branch: master #设置为master 8.配置SSH（我不确定是否必须，如果无法上传到Github的话，执行此步，否则可以不用。所以先看第九步）第一次使用要配置Git的一些东东，如果不是，估计你也知道SSH是啥了（反正我不知道qaq）在Git Bash里操作即可，如下：(注意按tab键可以补齐) 123456$ git config --global user.name &quot;随便写一个名字&quot;$ git config --global user.email &quot;你的邮箱&quot;$ ssh-keygen -t rsa -C &quot;你的邮箱&quot; #生成SSH$ cd ~/.ssh$ cat i（按Tab）（按.）（按Tab）【注：上一行打全了是 $ cat id_rsa.pub】 然后会出现一串东西，复制一下。打开Github，进入settings，按下图配置SSH。 9.写博文和部署博文在博客目录里的/source/_posts/中。一开始会有一个hello world.md文件。可以把它删掉、修改或者留着做测试，也可以阅读一下（反正我没读……）学习一下markdown就可以写出漂亮的文章了，并不难！ 每次更新了博客文章或者设置，首先在博客根目录下，打开Git Bash，输入 1$ hexo s 来进行测试，在浏览器里输入localhost:4000就可以进入测试页面了（注意图片无法显示，但是上传到Github上就可以了）如果4000端口被占用就百度一下，关键词“Hexo”、“4000占用”测试没问题了就可以部署了。 部署的时候，也是在博客根目录下，打开Git Bash，然后输入 1$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d #就用这个就行了，想要深入研究自行百度Hexo命令 这个时候在浏览器里输入 你的用户名.github.io就可以访问你的个人博客啦（当然你部署的时候得联网）。 10.其它 可能在hexo s时会报错，这里有几个参考的可能。一个是config文件里面的键值对（学过数据库的都知道），冒号后面要加空格。此外冒号必须用英文的冒号。 编辑的时候，尽量关闭测试（按Ctrl + C）。 测试要频繁，以免不知道自己哪里出错了。 隔一段时间要给博客做备份。把根目录压缩就可以了。 关于主题的配置自行研究。（/themes/主题名 里面也有一个config文件） 关于markdown的一系列操作也请百度学习。重要的内容会在之后的博文里更新。 部署到GitHub要有半分钟到一分钟后才能看到效果，毕竟上传要时间嘛。 第一次部署应该会要输入Github账号密码，如果没有，则说明配置有问题。可能可以部署，但是会没有样式。但是按我以上的配置应该是可以成功部署的。]]></content>
      <tags>
        <tag>网站</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DVWA-SQL Injection Low级]]></title>
    <url>%2Funln1999.github.io%2F2019%2F09%2F01%2F2SQLlow%2F</url>
    <content type="text"><![CDATA[斜体部分存疑，可能会有知识错误。 探究部分1.什么是SQL注入？SQL注入的英文全称是structrued query language injection。也即SQL injection。 谈论SQL注入必须首先了解什么是SQL。根据英文易知，SQL其实就是结构化查询语言的意思，是一种编程语言。用于查询和操作RDBMS（relational database management system，关系数据库管理系统）中的数据。 我们也容易见到MySQL、SQL server、oracle，这是三种常用且传统的RDBMS，传统的RDBMS都有统一的SQL语言操作接口（也就是说可以用SQL操作，根据了解并推测，传统RDBMS也只能用SQL语言来对数据进行查询和操作&lt;如果涵盖pl/sql等&gt;）。此外还有NoSQL数据库，这些数据库有自己特有的API接口，他们能做到传统RDBMS做不到的事，因此也有广泛应用。 许多网站的数据库都是这三种数据库之中的，因此利用页面表单来获取数据库信息时，在服务器中的程序（asp、php等编写的脚本程序）中必然要用到SQL语言，根据页面反馈的信息，我们可以推测这段SQL语句是如何书写的。假如我们可以利用这个SQL语句设计上的漏洞，我们就可以在执行或终止执行原有的SQL语句的基础上，执行我们想要执行的SQL命令，来获取数据库信息。 总之，SQL注入就是利用页面脚本设计中的漏洞在表单中插入SQL语句，欺骗服务器执行“恶意”的SQL命令。 备注：按百度百科的说法，还可以利用域名、页面请求来进行SQL注入。利用域名的我好像有看到过，页面请求不太懂是什么意思。在百度查后两种SQL注入找不到详细的介绍（在第一页）。在写这篇笔记到这里的时候，我才过了DVWA的low级SQL injection渗透测试，对利用表单进行SQL注入有一定的认识，而后两者还不了解。因此上文写到“在表单中插入SQL语句”。 2.SQL注入有哪几种方式？ 字符型注入：当表单要求获得字符时，传递到$query变量（或其它意义相同的SQL查询语句等）中时需要单引号或双引号，这时，如果表单中不对转义序列’或”进行过滤的话，就可能进行字符型注入。 数字型注入：当表单要求获得数字时，传递到$query变量（或其它意义相同的SQL查询语句等）中时，将没有单引号或双引号，直接输入数字+分号+想要服务器执行的SQL语句+注释– 就可能进行数字型注入。 利用数据库服务器的漏洞（不懂） 盲注（不懂） 根据条件响应（不懂） 条件性差错（不懂，大概是猜测数据库中的数据，如果数据存在会引起报错，从而得知特定数据的存在性） 时间延误（不懂，通过长SQL命令队列等，使服务器产生时间延误，也就是加载时间，通过时间长短，判断语句是否为真） 备注：这一部分主要从网上摘抄，前两个的详解是我个人目前的认识，也有可能不甚正确，因为前两种更为常见且比较简单，了解更多，后面几种了解甚微，原理一知半解。 3.如何避免SQL注入？ 首先要防范用户输入，永远不能信任用户输入，要对用户输入做出限制，比如禁止使用转义序列，甚至禁止使用特殊符号乃至禁止使用字母。简单的禁用还可以被绕过，比如AND被禁用了，有时可以用&amp;&amp;或者%26%26来代替，因此禁用有等级的区分，并且禁用部分输入对SQL注入的防范能力是有限的，可能会牺牲系统（指网站及其脚本）的性能等。因此不要简单认为禁用部分输入之后就可以一劳永逸。 不使用动态拼装的SQL语句，使用参数化的SQL语句（根据一个站点的介绍，asp、php不能够使用参数化SQL，因此要另寻它径，但是java、C#等语言可以） 每个应用对数据库的访问设限。比如DVWA靶机里的low级SQL注入就是一个很简单的根据id获取姓名的应用，不应该让它具有访问其它重要数据库的能力。 加密机密信息，即使泄露也难以破解。 对错误信息进行包装，或者抑制等等，不给用户“明注”（相对于“盲注”）的机会。后文的low级SQL注入中就大方地公开了错误信息，使得注入思路较为明确。SQL injection low级手工注入实践后台脚本源码12345678910111213141516171819202122232425262728293031323334353637&lt;?phpif( isset( $_REQUEST[ &apos;Submit&apos; ] ) ) &#123; // Get input $id = $_REQUEST[ &apos;id&apos; ]; // Check database $query = &quot;SELECT first_name, last_name FROM users WHERE user_id = &apos;$id&apos;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &apos;&lt;pre&gt;&apos; . ( (is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : ( ($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false ) ) . &apos;&lt;/pre&gt;&apos; ); // Get results while( $row = mysqli_fetch_assoc( $result ) ) &#123; // Get values $first = $row[&quot;first_name&quot;]; $last = $row[&quot;last_name&quot;]; // Feedback for end user $html .= &quot;&lt;pre&gt;ID: &#123;$id&#125;&lt;br /&gt;First name: &#123;$first&#125;&lt;br /&gt;Surname: &#123;$last&#125;&lt;/pre&gt;&quot;; &#125; mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]);&#125;?&gt; 解读后台脚本由php书写。 第一部分得到表单的值，当submit按钮被按下时，判断为真，执行后续语句——将name为’id’的input表单的值赋给变量$id。 声明字符串变量$query，其值为”SELECT first_name, last_name FROM users WHERE user_id = ‘$id’;” 因为这里是双引号，所以里面的变量$id会被表单中提交的内容所代替。 整个$query就是一个典型的SQL SELECT语句。根据《SQL参考手册》，SELECT语句可以为以下两种形式。 它的用处是在某张数据表中检索对应字段的数据并返回给用户。 接下来的mysqli_query()是php函数，语法如下： $GLOBALS[“___mysqli_ston”]是一个全局变量的写法，在这里用于MySQL连接。 $query即为查询字符串，这里之所以先声明这个变量，是为了阅读、处理、修改等的方便。 当SELECT语句查询成功时，mysqli_query()函数返回mysqli_result 对象，则$result也为一个object。 在php的bool or bool语句中，前一个为真，后一个bool值将不再被判断。（前一个值的数据类型可能不是布尔类型，但也对应真假） 因此此时or之后的语句将不再被执行。 然后将这个对象传递给mysqli_fetch_assoc()函数，来取得一行来作为关联数组。然后这里的while循环应该有一定执行次数，这大概和对象有关，因为我没有系统学习的面向对象编程的知识，这里无法详解while循环的执行过程，只能抽象地概括为，不断地从数据库中获取数据。 让变量$first获得”first_name”键对应的值，让变量$last获得”last_name”键对应的值。 $html是显示页面的变量，利用运算符”.=”在其后面加入&lt;pre&gt;标签来显示文本。 如果查询语句出错，则结束脚本，并进行嵌套的三元运算，首先判断$GLOBALS[“mysqli_ston”]是否是个对象，如果不是，那么检查连接有无错误，如果有，报错。如果无，说明数据库中没有对应id的记录。假如$GLOBALS[“mysqli_ston”]是对象，那么是用户输入有问题，利用mysqli_error()获得最近调用函数的最后一次错误并报错。这里的报错，为SQL注入提供了切入点。 SQL注入的思路则是在不知道脚本代码的情况下，推测出$query变量的值的形式，并在后续插入我们想要服务器执行的SQL命令。然后在mysqli_query()函数中发挥作用，取得mysqli_result对象。 实战1.输入数字1 得到正常的结果，还无法判断是否存在数字型、字符型注入。 根据URL中的显示，判断表单传递方式为GET。 2.输入’（判断是否存在注入以及类型） 得到报错信息：You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ‘’’’’ at line 1 可知第一行里出现了’’’，不是偶数，程序出错，有注入的可能。 3.输入” 无反应，也无报错，说明一切正常，只是数据库中没有id为’”‘的记录。 4.输入反斜杠\（反斜杠可以使有特殊功能的字符变成普通的字符，容易造成语句错误） 得到报错信息：You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ‘’&#39;‘ at line 1 可知第一行里出现了’\‘，并结合先前的试验，可以推测，这一块的内容类似于： ‘$_GET[‘id’]’ 因此，我们输入的字符串，被夹在两个单引号之间。 现在我们可以用诸如“1’;SQL语句；– ”、“1’ SQL语句 – ”来进行注入。或者就是“’;SQL语句；– ”、“’SQL语句 – ” 而这里需要的SQL语句需要一定的SQL基础。 备注：书写笔记至此，我为了能看懂SQL注入中究竟输入了些什么，已经学会了html基础、一半的基础CSS、大半的php，但是对SQL掌握不多，但是我会用SQL参考手册进行尝试。 5.输入永真语句’or 1(Select语句对每一行都是真的，因此$row遍历每一个记录并输出) 由此看出，该数据表的row为5行，尝试发现id是1、2、3、4、5。 至此可以判断url（http://127.0.0.1/DVWA-master/vulnerabilities/sqli/?id=&amp;Submit=Submit#）中的参数id存在注入点，存在字符型的SQL注入漏洞。 6.输入’ order by 3 – 利用order by语句搭配SELECT语句得知字段数(这里的数字应该是指第几个column) 当为3时报错：Unknown column ‘3’ in ‘order clause’ 因此字段数为2。 *7.或者用union select语句，union是一种高级的SQL操作符，比如输入’ union select 3，4 -- * ![image]/img/2-5.png) 之所以是这么显示，是因为第一个单引号为空，不对应任何字段。后面的union select根据SQL参考手册，column数必须与前面的相同。 同时我们利用union select获得了字段显示的位置，Web中，第一个字段显示在First name处，第二个字段显示在Surname处。 8.输入’ union select database(),version() – 利用SQL内置函数+不加from的union select语句得到数据库信息。 可知，数据库名称为dvwa，版本是5.5.53。 8.输入’ union select user(),version() -- 利用SQL内置函数+不加from的union select语句得到当前使用的用户信息。 9.输入’ union select @@version_compile_os,@@datadir -- 得到服务器的操作系统信息和数据库的存储目录（@@表示全局变量，类似于php里的$_GLOBAL[]） 10.现在加入from，从MySQL默认创建的数据库里获取需要的信息，先从infomation_schema（纲要）库中schemeta表中获取所有数据库的信息。 ![image]/img/2-9.png) 11.现在再在infomation_schema库的schemeta表中，对当前所用的数据库的表进行查询。 还有一种高端的写法： 备注：schemeta指数据库、table指表。information_schema数据库中的表及列都是固定而有规律的。这之后都是按经验、套路办事了。 12.获取users表中的列信息 13.获取用户名和密码：’ union select user,password from dvwa.users -- (这个注入命令是我找规律自己写的，可见我基本懂了，只是对information_schema库不熟悉) 猜测这是md5密文（有经验后，现在我没经验），发现可以登录dvwa靶机，SQL injection low级成功。 关于SQL map这里将不详讲，我照葫芦画瓢成功安装了SQL map。 在安装SQL map的时候需要安装python2。 在有python3的环境下，可以使用虚拟环境virtualenvwrapper。 利用SQL map可以方便地进行SQL注入测试与渗透。 参考网址（部分失效）：百科：https://baike.baidu.com/item/sql注入/150289?fr=aladdin CSDN一篇学习者日志: https://blog.csdn.net/ideality_hunter/article/details/80623526 上面那篇日志提到的参考：https://www.cnblogs.com/sdya/p/4568548.html 上面那篇参考的原文：https://www.cnblogs.com/rush/archive/2011/12/31/2309203.html 绕过过滤器：https://www.jianshu.com/p/a98edc0d2438 新人训练营：https://www.freebuf.com/column/184285.html 另一个SQL练习教程：https://blog.csdn.net/weixin_40586270/article/details/81631191 DVWA环境搭建：https://www.cnblogs.com/ECJTUACM-873284962/p/7784508.html Pip更新：http://www.51hsw.com/python-pipban-ben-geng-xin-de-wen-ti/ SQL map基本操作：https://www.jianshu.com/p/17509d0a1ba3 Phpstudy端口被占用：https://blog.csdn.net/weixin_43571641/article/details/83903804 全等级盲注：https://www.jianshu.com/p/757626cec742 low级手工注入：https://www.jianshu.com/p/54b630f1ec35 参数化SQL：https://www.cnblogs.com/yuyu666/p/9828065.html 未使用网址： 关于过滤SQL注入的文章：https://www.yuanmas.com/info/dnzlQnqqa6.html 关于post提交SQL数据：https://zhidao.baidu.com/question/1610843988763312667.html]]></content>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
</search>
